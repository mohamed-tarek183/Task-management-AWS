"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CdkToolkit = exports.AssetBuildTime = void 0;
exports.markTesting = markTesting;
const path = require("path");
const util_1 = require("util");
const cxapi = require("@aws-cdk/cx-api");
const chalk = require("chalk");
const chokidar = require("chokidar");
const fs = require("fs-extra");
const promptly = require("promptly");
const uuid = require("uuid");
const io_host_1 = require("./io-host");
const user_configuration_1 = require("./user-configuration");
const toolkit_lib_1 = require("../../../@aws-cdk/toolkit-lib");
const private_1 = require("../../../@aws-cdk/toolkit-lib/lib/api/io/private");
const payloads_1 = require("../../../@aws-cdk/toolkit-lib/lib/payloads");
const toolkit_1 = require("../../../@aws-cdk/toolkit-lib/lib/toolkit");
const api_1 = require("../api");
const bootstrap_1 = require("../api/bootstrap");
const cloud_assembly_1 = require("../api/cloud-assembly");
const garbage_collection_1 = require("../api/garbage-collection");
const hotswap_1 = require("../api/hotswap");
const logs_monitor_1 = require("../api/logs-monitor");
const resource_import_1 = require("../api/resource-import");
const tags_1 = require("../api/tags");
const work_graph_1 = require("../api/work-graph");
const api_private_1 = require("../api-private");
const deploy_1 = require("../commands/deploy");
const diff_1 = require("../commands/diff");
const list_stacks_1 = require("../commands/list-stacks");
const migrate_1 = require("../commands/migrate");
const cxapp_1 = require("../cxapp");
const logging_1 = require("../logging");
const util_2 = require("../util");
// Must use a require() otherwise esbuild complains about calling a namespace
// eslint-disable-next-line @typescript-eslint/no-require-imports,@typescript-eslint/consistent-type-imports
const pLimit = require('p-limit');
let TESTING = false;
function markTesting() {
    TESTING = true;
}
/**
 * When to build assets
 */
var AssetBuildTime;
(function (AssetBuildTime) {
    /**
     * Build all assets before deploying the first stack
     *
     * This is intended for expensive Docker image builds; so that if the Docker image build
     * fails, no stacks are unnecessarily deployed (with the attendant wait time).
     */
    AssetBuildTime["ALL_BEFORE_DEPLOY"] = "all-before-deploy";
    /**
     * Build assets just-in-time, before publishing
     */
    AssetBuildTime["JUST_IN_TIME"] = "just-in-time";
})(AssetBuildTime || (exports.AssetBuildTime = AssetBuildTime = {}));
class InternalToolkit extends toolkit_1.Toolkit {
    constructor(sdkProvider, options) {
        super(options);
        this._sdkProvider = sdkProvider;
    }
    /**
     * Access to the AWS SDK
     * @internal
     */
    async sdkProvider(_action) {
        return this._sdkProvider;
    }
}
/**
 * Toolkit logic
 *
 * The toolkit runs the `cloudExecutable` to obtain a cloud assembly and
 * deploys applies them to `cloudFormation`.
 */
class CdkToolkit {
    constructor(props) {
        this.props = props;
        this.ioHost = props.ioHost ?? io_host_1.CliIoHost.instance();
        this.toolkitStackName = props.toolkitStackName ?? api_1.DEFAULT_TOOLKIT_STACK_NAME;
        this.toolkit = new InternalToolkit(props.sdkProvider, {
            assemblyFailureAt: this.validateMetadataFailAt(),
            color: true,
            emojis: true,
            ioHost: this.ioHost,
            sdkConfig: {},
            toolkitStackName: this.toolkitStackName,
        });
        this.toolkit; // aritifical use of this.toolkit to satisfy TS, we want to prepare usage of the new toolkit without using it just yet
    }
    async metadata(stackName, json) {
        const stacks = await this.selectSingleStackByName(stackName);
        printSerializedObject(stacks.firstStack.manifest.metadata ?? {}, json);
    }
    async acknowledge(noticeId) {
        const acks = this.props.configuration.context.get('acknowledged-issue-numbers') ?? [];
        acks.push(Number(noticeId));
        this.props.configuration.context.set('acknowledged-issue-numbers', acks);
        await this.props.configuration.saveContext();
    }
    async diff(options) {
        const stacks = await this.selectStacksForDiff(options.stackNames, options.exclusively);
        const strict = !!options.strict;
        const contextLines = options.contextLines || 3;
        const quiet = options.quiet || false;
        let diffs = 0;
        const parameterMap = buildParameterMap(options.parameters);
        if (options.templatePath !== undefined) {
            // Compare single stack against fixed template
            if (stacks.stackCount !== 1) {
                throw new toolkit_lib_1.ToolkitError('Can only select one stack when comparing to fixed template. Use --exclusively to avoid selecting multiple stacks.');
            }
            if (!(await fs.pathExists(options.templatePath))) {
                throw new toolkit_lib_1.ToolkitError(`There is no file at ${options.templatePath}`);
            }
            const template = (0, util_2.deserializeStructure)(await fs.readFile(options.templatePath, { encoding: 'UTF-8' }));
            const formatter = new diff_1.DiffFormatter({
                ioHelper: (0, private_1.asIoHelper)(this.ioHost, 'diff'),
                templateInfo: {
                    oldTemplate: template,
                    newTemplate: stacks.firstStack,
                },
            });
            if (options.securityOnly) {
                const securityDiff = formatter.formatSecurityDiff();
                // Warn, count, and display the diff only if the reported changes are broadening permissions
                if (securityDiff.permissionChangeType === payloads_1.PermissionChangeType.BROADENING) {
                    (0, logging_1.warning)('This deployment will make potentially sensitive changes according to your current security approval level.\nPlease confirm you intend to make the following modifications:\n');
                    (0, logging_1.info)(securityDiff.formattedDiff);
                    diffs += 1;
                }
            }
            else {
                const diff = formatter.formatStackDiff({
                    strict,
                    context: contextLines,
                    quiet,
                });
                diffs = diff.numStacksWithChanges;
                (0, logging_1.info)(diff.formattedDiff);
            }
        }
        else {
            // Compare N stacks against deployed templates
            for (const stack of stacks.stackArtifacts) {
                const templateWithNestedStacks = await this.props.deployments.readCurrentTemplateWithNestedStacks(stack, options.compareAgainstProcessedTemplate);
                const currentTemplate = templateWithNestedStacks.deployedRootTemplate;
                const nestedStacks = templateWithNestedStacks.nestedStacks;
                const migrator = new resource_import_1.ResourceMigrator({
                    deployments: this.props.deployments,
                    ioHelper: (0, private_1.asIoHelper)(this.ioHost, 'diff'),
                });
                const resourcesToImport = await migrator.tryGetResources(await this.props.deployments.resolveEnvironment(stack));
                if (resourcesToImport) {
                    (0, resource_import_1.removeNonImportResources)(stack);
                }
                let changeSet = undefined;
                if (options.changeSet) {
                    let stackExists = false;
                    try {
                        stackExists = await this.props.deployments.stackExists({
                            stack,
                            deployName: stack.stackName,
                            tryLookupRole: true,
                        });
                    }
                    catch (e) {
                        (0, logging_1.debug)((0, util_2.formatErrorMessage)(e));
                        if (!quiet) {
                            (0, logging_1.info)(`Checking if the stack ${stack.stackName} exists before creating the changeset has failed, will base the diff on template differences (run again with -v to see the reason)\n`);
                        }
                        stackExists = false;
                    }
                    if (stackExists) {
                        changeSet = await api_private_1.cfnApi.createDiffChangeSet((0, private_1.asIoHelper)(this.ioHost, 'diff'), {
                            stack,
                            uuid: uuid.v4(),
                            deployments: this.props.deployments,
                            willExecute: false,
                            sdkProvider: this.props.sdkProvider,
                            parameters: Object.assign({}, parameterMap['*'], parameterMap[stack.stackName]),
                            resourcesToImport,
                        });
                    }
                    else {
                        (0, logging_1.debug)(`the stack '${stack.stackName}' has not been deployed to CloudFormation or describeStacks call failed, skipping changeset creation.`);
                    }
                }
                const formatter = new diff_1.DiffFormatter({
                    ioHelper: (0, private_1.asIoHelper)(this.ioHost, 'diff'),
                    templateInfo: {
                        oldTemplate: currentTemplate,
                        newTemplate: stack,
                        changeSet,
                        isImport: !!resourcesToImport,
                        nestedStacks,
                    },
                });
                if (options.securityOnly) {
                    const securityDiff = formatter.formatSecurityDiff();
                    // Warn, count, and display the diff only if the reported changes are broadening permissions
                    if (securityDiff.permissionChangeType === payloads_1.PermissionChangeType.BROADENING) {
                        (0, logging_1.warning)('This deployment will make potentially sensitive changes according to your current security approval level.\nPlease confirm you intend to make the following modifications:\n');
                        (0, logging_1.info)(securityDiff.formattedDiff);
                        diffs += 1;
                    }
                }
                else {
                    const diff = formatter.formatStackDiff({
                        strict,
                        context: contextLines,
                        quiet,
                    });
                    (0, logging_1.info)(diff.formattedDiff);
                    diffs += diff.numStacksWithChanges;
                }
            }
        }
        (0, logging_1.info)((0, util_1.format)('\n✨  Number of stacks with differences: %s\n', diffs));
        return diffs && options.fail ? 1 : 0;
    }
    async deploy(options) {
        if (options.watch) {
            return this.watch(options);
        }
        // set progress from options, this includes user and app config
        if (options.progress) {
            this.ioHost.stackProgress = options.progress;
        }
        const startSynthTime = new Date().getTime();
        const stackCollection = await this.selectStacksForDeploy(options.selector, options.exclusively, options.cacheCloudAssembly, options.ignoreNoStacks);
        const elapsedSynthTime = new Date().getTime() - startSynthTime;
        (0, logging_1.info)(`\n✨  Synthesis time: ${(0, util_2.formatTime)(elapsedSynthTime)}s\n`);
        if (stackCollection.stackCount === 0) {
            (0, logging_1.error)('This app contains no stacks');
            return;
        }
        const migrator = new resource_import_1.ResourceMigrator({
            deployments: this.props.deployments,
            ioHelper: (0, private_1.asIoHelper)(this.ioHost, 'deploy'),
        });
        await migrator.tryMigrateResources(stackCollection, {
            toolkitStackName: this.toolkitStackName,
            ...options,
        });
        const requireApproval = options.requireApproval ?? diff_1.RequireApproval.BROADENING;
        const parameterMap = buildParameterMap(options.parameters);
        if (options.hotswap !== hotswap_1.HotswapMode.FULL_DEPLOYMENT) {
            (0, logging_1.warning)('⚠️ The --hotswap and --hotswap-fallback flags deliberately introduce CloudFormation drift to speed up deployments');
            (0, logging_1.warning)('⚠️ They should only be used for development - never use them for your production Stacks!\n');
        }
        let hotswapPropertiesFromSettings = this.props.configuration.settings.get(['hotswap']) || {};
        let hotswapPropertyOverrides = new hotswap_1.HotswapPropertyOverrides();
        hotswapPropertyOverrides.ecsHotswapProperties = new hotswap_1.EcsHotswapProperties(hotswapPropertiesFromSettings.ecs?.minimumHealthyPercent, hotswapPropertiesFromSettings.ecs?.maximumHealthyPercent);
        const stacks = stackCollection.stackArtifacts;
        const stackOutputs = {};
        const outputsFile = options.outputsFile;
        const buildAsset = async (assetNode) => {
            await this.props.deployments.buildSingleAsset(assetNode.assetManifestArtifact, assetNode.assetManifest, assetNode.asset, {
                stack: assetNode.parentStack,
                roleArn: options.roleArn,
                stackName: assetNode.parentStack.stackName,
            });
        };
        const publishAsset = async (assetNode) => {
            await this.props.deployments.publishSingleAsset(assetNode.assetManifest, assetNode.asset, {
                stack: assetNode.parentStack,
                roleArn: options.roleArn,
                stackName: assetNode.parentStack.stackName,
                forcePublish: options.force,
            });
        };
        const deployStack = async (stackNode) => {
            const stack = stackNode.stack;
            if (stackCollection.stackCount !== 1) {
                (0, logging_1.highlight)(stack.displayName);
            }
            if (!stack.environment) {
                // eslint-disable-next-line @stylistic/max-len
                throw new toolkit_lib_1.ToolkitError(`Stack ${stack.displayName} does not define an environment, and AWS credentials could not be obtained from standard locations or no region was configured.`);
            }
            if (Object.keys(stack.template.Resources || {}).length === 0) {
                // The generated stack has no resources
                if (!(await this.props.deployments.stackExists({ stack }))) {
                    (0, logging_1.warning)('%s: stack has no resources, skipping deployment.', chalk.bold(stack.displayName));
                }
                else {
                    (0, logging_1.warning)('%s: stack has no resources, deleting existing stack.', chalk.bold(stack.displayName));
                    await this.destroy({
                        selector: { patterns: [stack.hierarchicalId] },
                        exclusively: true,
                        force: true,
                        roleArn: options.roleArn,
                        fromDeploy: true,
                    });
                }
                return;
            }
            if (requireApproval !== diff_1.RequireApproval.NEVER) {
                const currentTemplate = await this.props.deployments.readCurrentTemplate(stack);
                const formatter = new diff_1.DiffFormatter({
                    ioHelper: (0, private_1.asIoHelper)(this.ioHost, 'deploy'),
                    templateInfo: {
                        oldTemplate: currentTemplate,
                        newTemplate: stack,
                    },
                });
                const securityDiff = formatter.formatSecurityDiff();
                if (requiresApproval(requireApproval, securityDiff.permissionChangeType)) {
                    (0, logging_1.info)(securityDiff.formattedDiff);
                    await askUserConfirmation(this.ioHost, concurrency, '"--require-approval" is enabled and stack includes security-sensitive updates', 'Do you wish to deploy these changes');
                }
            }
            // Following are the same semantics we apply with respect to Notification ARNs (dictated by the SDK)
            //
            //  - undefined  =>  cdk ignores it, as if it wasn't supported (allows external management).
            //  - []:        =>  cdk manages it, and the user wants to wipe it out.
            //  - ['arn-1']  =>  cdk manages it, and the user wants to set it to ['arn-1'].
            const notificationArns = (!!options.notificationArns || !!stack.notificationArns)
                ? (options.notificationArns ?? []).concat(stack.notificationArns ?? [])
                : undefined;
            for (const notificationArn of notificationArns ?? []) {
                if (!(0, util_2.validateSnsTopicArn)(notificationArn)) {
                    throw new toolkit_lib_1.ToolkitError(`Notification arn ${notificationArn} is not a valid arn for an SNS topic`);
                }
            }
            const stackIndex = stacks.indexOf(stack) + 1;
            (0, logging_1.info)(`${chalk.bold(stack.displayName)}: deploying... [${stackIndex}/${stackCollection.stackCount}]`);
            const startDeployTime = new Date().getTime();
            let tags = options.tags;
            if (!tags || tags.length === 0) {
                tags = (0, tags_1.tagsForStack)(stack);
            }
            let elapsedDeployTime = 0;
            try {
                let deployResult;
                let rollback = options.rollback;
                let iteration = 0;
                while (!deployResult) {
                    if (++iteration > 2) {
                        throw new toolkit_lib_1.ToolkitError('This loop should have stabilized in 2 iterations, but didn\'t. If you are seeing this error, please report it at https://github.com/aws/aws-cdk/issues/new/choose');
                    }
                    const r = await this.props.deployments.deployStack({
                        stack,
                        deployName: stack.stackName,
                        roleArn: options.roleArn,
                        toolkitStackName: options.toolkitStackName,
                        reuseAssets: options.reuseAssets,
                        notificationArns,
                        tags,
                        execute: options.execute,
                        changeSetName: options.changeSetName,
                        deploymentMethod: options.deploymentMethod,
                        forceDeployment: options.force,
                        parameters: Object.assign({}, parameterMap['*'], parameterMap[stack.stackName]),
                        usePreviousParameters: options.usePreviousParameters,
                        rollback,
                        hotswap: options.hotswap,
                        hotswapPropertyOverrides: hotswapPropertyOverrides,
                        extraUserAgent: options.extraUserAgent,
                        assetParallelism: options.assetParallelism,
                        ignoreNoStacks: options.ignoreNoStacks,
                    });
                    switch (r.type) {
                        case 'did-deploy-stack':
                            deployResult = r;
                            break;
                        case 'failpaused-need-rollback-first': {
                            const motivation = r.reason === 'replacement'
                                ? `Stack is in a paused fail state (${r.status}) and change includes a replacement which cannot be deployed with "--no-rollback"`
                                : `Stack is in a paused fail state (${r.status}) and command line arguments do not include "--no-rollback"`;
                            if (options.force) {
                                (0, logging_1.warning)(`${motivation}. Rolling back first (--force).`);
                            }
                            else {
                                await askUserConfirmation(this.ioHost, concurrency, motivation, `${motivation}. Roll back first and then proceed with deployment`);
                            }
                            // Perform a rollback
                            await this.rollback({
                                selector: { patterns: [stack.hierarchicalId] },
                                toolkitStackName: options.toolkitStackName,
                                force: options.force,
                            });
                            // Go around through the 'while' loop again but switch rollback to true.
                            rollback = true;
                            break;
                        }
                        case 'replacement-requires-rollback': {
                            const motivation = 'Change includes a replacement which cannot be deployed with "--no-rollback"';
                            if (options.force) {
                                (0, logging_1.warning)(`${motivation}. Proceeding with regular deployment (--force).`);
                            }
                            else {
                                await askUserConfirmation(this.ioHost, concurrency, motivation, `${motivation}. Perform a regular deployment`);
                            }
                            // Go around through the 'while' loop again but switch rollback to true.
                            rollback = true;
                            break;
                        }
                        default:
                            throw new toolkit_lib_1.ToolkitError(`Unexpected result type from deployStack: ${JSON.stringify(r)}. If you are seeing this error, please report it at https://github.com/aws/aws-cdk/issues/new/choose`);
                    }
                }
                const message = deployResult.noOp
                    ? ' ✅  %s (no changes)'
                    : ' ✅  %s';
                (0, logging_1.success)('\n' + message, stack.displayName);
                elapsedDeployTime = new Date().getTime() - startDeployTime;
                (0, logging_1.info)(`\n✨  Deployment time: ${(0, util_2.formatTime)(elapsedDeployTime)}s\n`);
                if (Object.keys(deployResult.outputs).length > 0) {
                    (0, logging_1.info)('Outputs:');
                    stackOutputs[stack.stackName] = deployResult.outputs;
                }
                for (const name of Object.keys(deployResult.outputs).sort()) {
                    const value = deployResult.outputs[name];
                    (0, logging_1.info)(`${chalk.cyan(stack.id)}.${chalk.cyan(name)} = ${chalk.underline(chalk.cyan(value))}`);
                }
                (0, logging_1.info)('Stack ARN:');
                (0, logging_1.result)(deployResult.stackArn);
            }
            catch (e) {
                // It has to be exactly this string because an integration test tests for
                // "bold(stackname) failed: ResourceNotReady: <error>"
                throw new toolkit_lib_1.ToolkitError([`❌  ${chalk.bold(stack.stackName)} failed:`, ...(e.name ? [`${e.name}:`] : []), (0, util_2.formatErrorMessage)(e)].join(' '));
            }
            finally {
                if (options.cloudWatchLogMonitor) {
                    const foundLogGroupsResult = await (0, logs_monitor_1.findCloudWatchLogGroups)(this.props.sdkProvider, (0, private_1.asIoHelper)(this.ioHost, 'deploy'), stack);
                    options.cloudWatchLogMonitor.addLogGroups(foundLogGroupsResult.env, foundLogGroupsResult.sdk, foundLogGroupsResult.logGroupNames);
                }
                // If an outputs file has been specified, create the file path and write stack outputs to it once.
                // Outputs are written after all stacks have been deployed. If a stack deployment fails,
                // all of the outputs from successfully deployed stacks before the failure will still be written.
                if (outputsFile) {
                    fs.ensureFileSync(outputsFile);
                    await fs.writeJson(outputsFile, stackOutputs, {
                        spaces: 2,
                        encoding: 'utf8',
                    });
                }
            }
            (0, logging_1.info)(`\n✨  Total time: ${(0, util_2.formatTime)(elapsedSynthTime + elapsedDeployTime)}s\n`);
        };
        const assetBuildTime = options.assetBuildTime ?? AssetBuildTime.ALL_BEFORE_DEPLOY;
        const prebuildAssets = assetBuildTime === AssetBuildTime.ALL_BEFORE_DEPLOY;
        const concurrency = options.concurrency || 1;
        if (concurrency > 1) {
            // always force "events" progress output when we have concurrency
            this.ioHost.stackProgress = deploy_1.StackActivityProgress.EVENTS;
            // ...but only warn if the user explicitly requested "bar" progress
            if (options.progress && options.progress != deploy_1.StackActivityProgress.EVENTS) {
                (0, logging_1.warning)('⚠️ The --concurrency flag only supports --progress "events". Switching to "events".');
            }
        }
        const stacksAndTheirAssetManifests = stacks.flatMap((stack) => [
            stack,
            ...stack.dependencies.filter(x => cxapi.AssetManifestArtifact.isAssetManifestArtifact(x)),
        ]);
        const workGraph = new work_graph_1.WorkGraphBuilder((0, private_1.asIoHelper)(this.ioHost, 'deploy'), prebuildAssets).build(stacksAndTheirAssetManifests);
        // Unless we are running with '--force', skip already published assets
        if (!options.force) {
            await this.removePublishedAssets(workGraph, options);
        }
        const graphConcurrency = {
            'stack': concurrency,
            'asset-build': 1, // This will be CPU-bound/memory bound, mostly matters for Docker builds
            'asset-publish': (options.assetParallelism ?? true) ? 8 : 1, // This will be I/O-bound, 8 in parallel seems reasonable
        };
        await workGraph.doParallel(graphConcurrency, {
            deployStack,
            buildAsset,
            publishAsset,
        });
    }
    /**
     * Roll back the given stack or stacks.
     */
    async rollback(options) {
        const startSynthTime = new Date().getTime();
        const stackCollection = await this.selectStacksForDeploy(options.selector, true);
        const elapsedSynthTime = new Date().getTime() - startSynthTime;
        (0, logging_1.info)(`\n✨  Synthesis time: ${(0, util_2.formatTime)(elapsedSynthTime)}s\n`);
        if (stackCollection.stackCount === 0) {
            (0, logging_1.error)('No stacks selected');
            return;
        }
        let anyRollbackable = false;
        for (const stack of stackCollection.stackArtifacts) {
            (0, logging_1.info)('Rolling back %s', chalk.bold(stack.displayName));
            const startRollbackTime = new Date().getTime();
            try {
                const result = await this.props.deployments.rollbackStack({
                    stack,
                    roleArn: options.roleArn,
                    toolkitStackName: options.toolkitStackName,
                    orphanFailedResources: options.force,
                    validateBootstrapStackVersion: options.validateBootstrapStackVersion,
                    orphanLogicalIds: options.orphanLogicalIds,
                });
                if (!result.notInRollbackableState) {
                    anyRollbackable = true;
                }
                const elapsedRollbackTime = new Date().getTime() - startRollbackTime;
                (0, logging_1.info)(`\n✨  Rollback time: ${(0, util_2.formatTime)(elapsedRollbackTime).toString()}s\n`);
            }
            catch (e) {
                (0, logging_1.error)('\n ❌  %s failed: %s', chalk.bold(stack.displayName), (0, util_2.formatErrorMessage)(e));
                throw new toolkit_lib_1.ToolkitError('Rollback failed (use --force to orphan failing resources)');
            }
        }
        if (!anyRollbackable) {
            throw new toolkit_lib_1.ToolkitError('No stacks were in a state that could be rolled back');
        }
    }
    async watch(options) {
        const rootDir = path.dirname(path.resolve(user_configuration_1.PROJECT_CONFIG));
        const ioHelper = (0, private_1.asIoHelper)(this.ioHost, 'watch');
        (0, logging_1.debug)("root directory used for 'watch' is: %s", rootDir);
        const watchSettings = this.props.configuration.settings.get(['watch']);
        if (!watchSettings) {
            throw new toolkit_lib_1.ToolkitError("Cannot use the 'watch' command without specifying at least one directory to monitor. " +
                'Make sure to add a "watch" key to your cdk.json');
        }
        // For the "include" subkey under the "watch" key, the behavior is:
        // 1. No "watch" setting? We error out.
        // 2. "watch" setting without an "include" key? We default to observing "./**".
        // 3. "watch" setting with an empty "include" key? We default to observing "./**".
        // 4. Non-empty "include" key? Just use the "include" key.
        const watchIncludes = this.patternsArrayForWatch(watchSettings.include, {
            rootDir,
            returnRootDirIfEmpty: true,
        });
        (0, logging_1.debug)("'include' patterns for 'watch': %s", watchIncludes);
        // For the "exclude" subkey under the "watch" key,
        // the behavior is to add some default excludes in addition to the ones specified by the user:
        // 1. The CDK output directory.
        // 2. Any file whose name starts with a dot.
        // 3. Any directory's content whose name starts with a dot.
        // 4. Any node_modules and its content (even if it's not a JS/TS project, you might be using a local aws-cli package)
        const outputDir = this.props.configuration.settings.get(['output']);
        const watchExcludes = this.patternsArrayForWatch(watchSettings.exclude, {
            rootDir,
            returnRootDirIfEmpty: false,
        }).concat(`${outputDir}/**`, '**/.*', '**/.*/**', '**/node_modules/**');
        (0, logging_1.debug)("'exclude' patterns for 'watch': %s", watchExcludes);
        // Since 'cdk deploy' is a relatively slow operation for a 'watch' process,
        // introduce a concurrency latch that tracks the state.
        // This way, if file change events arrive when a 'cdk deploy' is still executing,
        // we will batch them, and trigger another 'cdk deploy' after the current one finishes,
        // making sure 'cdk deploy's  always execute one at a time.
        // Here's a diagram showing the state transitions:
        // --------------                --------    file changed     --------------    file changed     --------------  file changed
        // |            |  ready event   |      | ------------------> |            | ------------------> |            | --------------|
        // | pre-ready  | -------------> | open |                     | deploying  |                     |   queued   |               |
        // |            |                |      | <------------------ |            | <------------------ |            | <-------------|
        // --------------                --------  'cdk deploy' done  --------------  'cdk deploy' done  --------------
        let latch = 'pre-ready';
        const cloudWatchLogMonitor = options.traceLogs ? new logs_monitor_1.CloudWatchLogEventMonitor({
            ioHelper,
        }) : undefined;
        const deployAndWatch = async () => {
            latch = 'deploying';
            await cloudWatchLogMonitor?.deactivate();
            await this.invokeDeployFromWatch(options, cloudWatchLogMonitor);
            // If latch is still 'deploying' after the 'await', that's fine,
            // but if it's 'queued', that means we need to deploy again
            while (latch === 'queued') {
                // TypeScript doesn't realize latch can change between 'awaits',
                // and thinks the above 'while' condition is always 'false' without the cast
                latch = 'deploying';
                (0, logging_1.info)("Detected file changes during deployment. Invoking 'cdk deploy' again");
                await this.invokeDeployFromWatch(options, cloudWatchLogMonitor);
            }
            latch = 'open';
            await cloudWatchLogMonitor?.activate();
        };
        chokidar
            .watch(watchIncludes, {
            ignored: watchExcludes,
            cwd: rootDir,
        })
            .on('ready', async () => {
            latch = 'open';
            (0, logging_1.debug)("'watch' received the 'ready' event. From now on, all file changes will trigger a deployment");
            (0, logging_1.info)("Triggering initial 'cdk deploy'");
            await deployAndWatch();
        })
            .on('all', async (event, filePath) => {
            if (latch === 'pre-ready') {
                (0, logging_1.info)(`'watch' is observing ${event === 'addDir' ? 'directory' : 'the file'} '%s' for changes`, filePath);
            }
            else if (latch === 'open') {
                (0, logging_1.info)("Detected change to '%s' (type: %s). Triggering 'cdk deploy'", filePath, event);
                await deployAndWatch();
            }
            else {
                // this means latch is either 'deploying' or 'queued'
                latch = 'queued';
                (0, logging_1.info)("Detected change to '%s' (type: %s) while 'cdk deploy' is still running. " +
                    'Will queue for another deployment after this one finishes', filePath, event);
            }
        });
    }
    async import(options) {
        const stacks = await this.selectStacksForDeploy(options.selector, true, true, false);
        // set progress from options, this includes user and app config
        if (options.progress) {
            this.ioHost.stackProgress = options.progress;
        }
        if (stacks.stackCount > 1) {
            throw new toolkit_lib_1.ToolkitError(`Stack selection is ambiguous, please choose a specific stack for import [${stacks.stackArtifacts.map((x) => x.id).join(', ')}]`);
        }
        if (!process.stdout.isTTY && !options.resourceMappingFile) {
            throw new toolkit_lib_1.ToolkitError('--resource-mapping is required when input is not a terminal');
        }
        const stack = stacks.stackArtifacts[0];
        (0, logging_1.highlight)(stack.displayName);
        const resourceImporter = new resource_import_1.ResourceImporter(stack, {
            deployments: this.props.deployments,
            ioHelper: (0, private_1.asIoHelper)(this.ioHost, 'import'),
        });
        const { additions, hasNonAdditions } = await resourceImporter.discoverImportableResources(options.force);
        if (additions.length === 0) {
            (0, logging_1.warning)('%s: no new resources compared to the currently deployed stack, skipping import.', chalk.bold(stack.displayName));
            return;
        }
        // Prepare a mapping of physical resources to CDK constructs
        const actualImport = !options.resourceMappingFile
            ? await resourceImporter.askForResourceIdentifiers(additions)
            : await resourceImporter.loadResourceIdentifiers(additions, options.resourceMappingFile);
        if (actualImport.importResources.length === 0) {
            (0, logging_1.warning)('No resources selected for import.');
            return;
        }
        // If "--create-resource-mapping" option was passed, write the resource mapping to the given file and exit
        if (options.recordResourceMapping) {
            const outputFile = options.recordResourceMapping;
            fs.ensureFileSync(outputFile);
            await fs.writeJson(outputFile, actualImport.resourceMap, {
                spaces: 2,
                encoding: 'utf8',
            });
            (0, logging_1.info)('%s: mapping file written.', outputFile);
            return;
        }
        // Import the resources according to the given mapping
        (0, logging_1.info)('%s: importing resources into stack...', chalk.bold(stack.displayName));
        const tags = (0, tags_1.tagsForStack)(stack);
        await resourceImporter.importResourcesFromMap(actualImport, {
            roleArn: options.roleArn,
            tags,
            deploymentMethod: options.deploymentMethod,
            usePreviousParameters: true,
            rollback: options.rollback,
        });
        // Notify user of next steps
        (0, logging_1.info)(`Import operation complete. We recommend you run a ${chalk.blueBright('drift detection')} operation ` +
            'to confirm your CDK app resource definitions are up-to-date. Read more here: ' +
            chalk.underline.blueBright('https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/detect-drift-stack.html'));
        if (actualImport.importResources.length < additions.length) {
            (0, logging_1.info)('');
            (0, logging_1.warning)(`Some resources were skipped. Run another ${chalk.blueBright('cdk import')} or a ${chalk.blueBright('cdk deploy')} to bring the stack up-to-date with your CDK app definition.`);
        }
        else if (hasNonAdditions) {
            (0, logging_1.info)('');
            (0, logging_1.warning)(`Your app has pending updates or deletes excluded from this import operation. Run a ${chalk.blueBright('cdk deploy')} to bring the stack up-to-date with your CDK app definition.`);
        }
    }
    async destroy(options) {
        let stacks = await this.selectStacksForDestroy(options.selector, options.exclusively);
        // The stacks will have been ordered for deployment, so reverse them for deletion.
        stacks = stacks.reversed();
        if (!options.force) {
            // eslint-disable-next-line @stylistic/max-len
            const confirmed = await promptly.confirm(`Are you sure you want to delete: ${chalk.blue(stacks.stackArtifacts.map((s) => s.hierarchicalId).join(', '))} (y/n)?`);
            if (!confirmed) {
                return;
            }
        }
        const action = options.fromDeploy ? 'deploy' : 'destroy';
        for (const [index, stack] of stacks.stackArtifacts.entries()) {
            (0, logging_1.success)('%s: destroying... [%s/%s]', chalk.blue(stack.displayName), index + 1, stacks.stackCount);
            try {
                await this.props.deployments.destroyStack({
                    stack,
                    deployName: stack.stackName,
                    roleArn: options.roleArn,
                });
                (0, logging_1.success)(`\n ✅  %s: ${action}ed`, chalk.blue(stack.displayName));
            }
            catch (e) {
                (0, logging_1.error)(`\n ❌  %s: ${action} failed`, chalk.blue(stack.displayName), e);
                throw e;
            }
        }
    }
    async list(selectors, options = {}) {
        const stacks = await (0, list_stacks_1.listStacks)(this, {
            selectors: selectors,
        });
        if (options.long && options.showDeps) {
            printSerializedObject(stacks, options.json ?? false);
            return 0;
        }
        if (options.showDeps) {
            const stackDeps = [];
            for (const stack of stacks) {
                stackDeps.push({
                    id: stack.id,
                    dependencies: stack.dependencies,
                });
            }
            printSerializedObject(stackDeps, options.json ?? false);
            return 0;
        }
        if (options.long) {
            const long = [];
            for (const stack of stacks) {
                long.push({
                    id: stack.id,
                    name: stack.name,
                    environment: stack.environment,
                });
            }
            printSerializedObject(long, options.json ?? false);
            return 0;
        }
        // just print stack IDs
        for (const stack of stacks) {
            (0, logging_1.result)(stack.id);
        }
        return 0; // exit-code
    }
    /**
     * Synthesize the given set of stacks (called when the user runs 'cdk synth')
     *
     * INPUT: Stack names can be supplied using a glob filter. If no stacks are
     * given, all stacks from the application are implicitly selected.
     *
     * OUTPUT: If more than one stack ends up being selected, an output directory
     * should be supplied, where the templates will be written.
     */
    async synth(stackNames, exclusively, quiet, autoValidate, json) {
        const stacks = await this.selectStacksForDiff(stackNames, exclusively, autoValidate);
        // if we have a single stack, print it to STDOUT
        if (stacks.stackCount === 1) {
            if (!quiet) {
                printSerializedObject((0, util_2.obscureTemplate)(stacks.firstStack.template), json ?? false);
            }
            return undefined;
        }
        // not outputting template to stdout, let's explain things to the user a little bit...
        (0, logging_1.success)(`Successfully synthesized to ${chalk.blue(path.resolve(stacks.assembly.directory))}`);
        (0, logging_1.info)(`Supply a stack id (${stacks.stackArtifacts.map((s) => chalk.green(s.hierarchicalId)).join(', ')}) to display its template.`);
        return undefined;
    }
    /**
     * Bootstrap the CDK Toolkit stack in the accounts used by the specified stack(s).
     *
     * @param userEnvironmentSpecs environment names that need to have toolkit support
     *             provisioned, as a glob filter. If none is provided, all stacks are implicitly selected.
     * @param options The name, role ARN, bootstrapping parameters, etc. to be used for the CDK Toolkit stack.
     */
    async bootstrap(userEnvironmentSpecs, options) {
        const bootstrapper = new bootstrap_1.Bootstrapper(options.source, (0, private_1.asIoHelper)(this.ioHost, 'bootstrap'));
        // If there is an '--app' argument and an environment looks like a glob, we
        // select the environments from the app. Otherwise, use what the user said.
        const environments = await this.defineEnvironments(userEnvironmentSpecs);
        const limit = pLimit(20);
        // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
        await Promise.all(environments.map((environment) => limit(async () => {
            (0, logging_1.success)(' ⏳  Bootstrapping environment %s...', chalk.blue(environment.name));
            try {
                const result = await bootstrapper.bootstrapEnvironment(environment, this.props.sdkProvider, options);
                const message = result.noOp
                    ? ' ✅  Environment %s bootstrapped (no changes).'
                    : ' ✅  Environment %s bootstrapped.';
                (0, logging_1.success)(message, chalk.blue(environment.name));
            }
            catch (e) {
                (0, logging_1.error)(' ❌  Environment %s failed bootstrapping: %s', chalk.blue(environment.name), e);
                throw e;
            }
        })));
    }
    /**
     * Garbage collects assets from a CDK app's environment
     * @param options Options for Garbage Collection
     */
    async garbageCollect(userEnvironmentSpecs, options) {
        const environments = await this.defineEnvironments(userEnvironmentSpecs);
        for (const environment of environments) {
            (0, logging_1.success)(' ⏳  Garbage Collecting environment %s...', chalk.blue(environment.name));
            const gc = new garbage_collection_1.GarbageCollector({
                sdkProvider: this.props.sdkProvider,
                ioHelper: (0, private_1.asIoHelper)(this.ioHost, 'gc'),
                resolvedEnvironment: environment,
                bootstrapStackName: options.bootstrapStackName,
                rollbackBufferDays: options.rollbackBufferDays,
                createdBufferDays: options.createdBufferDays,
                action: options.action ?? 'full',
                type: options.type ?? 'all',
                confirm: options.confirm ?? true,
            });
            await gc.garbageCollect();
        }
    }
    async defineEnvironments(userEnvironmentSpecs) {
        // By default, glob for everything
        const environmentSpecs = userEnvironmentSpecs.length > 0 ? [...userEnvironmentSpecs] : ['**'];
        // Partition into globs and non-globs (this will mutate environmentSpecs).
        const globSpecs = (0, util_2.partition)(environmentSpecs, cxapp_1.looksLikeGlob);
        if (globSpecs.length > 0 && !this.props.cloudExecutable.hasApp) {
            if (userEnvironmentSpecs.length > 0) {
                // User did request this glob
                throw new toolkit_lib_1.ToolkitError(`'${globSpecs}' is not an environment name. Specify an environment name like 'aws://123456789012/us-east-1', or run in a directory with 'cdk.json' to use wildcards.`);
            }
            else {
                // User did not request anything
                throw new toolkit_lib_1.ToolkitError("Specify an environment name like 'aws://123456789012/us-east-1', or run in a directory with 'cdk.json'.");
            }
        }
        const environments = [...(0, cxapp_1.environmentsFromDescriptors)(environmentSpecs)];
        // If there is an '--app' argument, select the environments from the app.
        if (this.props.cloudExecutable.hasApp) {
            environments.push(...(await (0, cxapp_1.globEnvironmentsFromStacks)(await this.selectStacksForList([]), globSpecs, this.props.sdkProvider)));
        }
        return environments;
    }
    /**
     * Migrates a CloudFormation stack/template to a CDK app
     * @param options Options for CDK app creation
     */
    async migrate(options) {
        (0, logging_1.warning)('This command is an experimental feature.');
        const language = options.language?.toLowerCase() ?? 'typescript';
        const environment = (0, migrate_1.setEnvironment)(options.account, options.region);
        let generateTemplateOutput;
        let cfn;
        let templateToDelete;
        try {
            // if neither fromPath nor fromStack is provided, generate a template using cloudformation
            const scanType = (0, migrate_1.parseSourceOptions)(options.fromPath, options.fromStack, options.stackName).source;
            if (scanType == migrate_1.TemplateSourceOptions.SCAN) {
                generateTemplateOutput = await (0, migrate_1.generateTemplate)({
                    stackName: options.stackName,
                    filters: options.filter,
                    fromScan: options.fromScan,
                    sdkProvider: this.props.sdkProvider,
                    environment: environment,
                });
                templateToDelete = generateTemplateOutput.templateId;
            }
            else if (scanType == migrate_1.TemplateSourceOptions.PATH) {
                const templateBody = (0, migrate_1.readFromPath)(options.fromPath);
                const parsedTemplate = (0, util_2.deserializeStructure)(templateBody);
                const templateId = parsedTemplate.Metadata?.TemplateId?.toString();
                if (templateId) {
                    // if we have a template id, we can call describe generated template to get the resource identifiers
                    // resource metadata, and template source to generate the template
                    cfn = new migrate_1.CfnTemplateGeneratorProvider(await (0, migrate_1.buildCfnClient)(this.props.sdkProvider, environment));
                    const generatedTemplateSummary = await cfn.describeGeneratedTemplate(templateId);
                    generateTemplateOutput = (0, migrate_1.buildGenertedTemplateOutput)(generatedTemplateSummary, templateBody, generatedTemplateSummary.GeneratedTemplateId);
                }
                else {
                    generateTemplateOutput = {
                        migrateJson: {
                            templateBody: templateBody,
                            source: 'localfile',
                        },
                    };
                }
            }
            else if (scanType == migrate_1.TemplateSourceOptions.STACK) {
                const template = await (0, migrate_1.readFromStack)(options.stackName, this.props.sdkProvider, environment);
                if (!template) {
                    throw new toolkit_lib_1.ToolkitError(`No template found for stack-name: ${options.stackName}`);
                }
                generateTemplateOutput = {
                    migrateJson: {
                        templateBody: template,
                        source: options.stackName,
                    },
                };
            }
            else {
                // We shouldn't ever get here, but just in case.
                throw new toolkit_lib_1.ToolkitError(`Invalid source option provided: ${scanType}`);
            }
            const stack = (0, migrate_1.generateStack)(generateTemplateOutput.migrateJson.templateBody, options.stackName, language);
            (0, logging_1.success)(' ⏳  Generating CDK app for %s...', chalk.blue(options.stackName));
            await (0, migrate_1.generateCdkApp)(options.stackName, stack, language, options.outputPath, options.compress);
            if (generateTemplateOutput) {
                (0, migrate_1.writeMigrateJsonFile)(options.outputPath, options.stackName, generateTemplateOutput.migrateJson);
            }
            if ((0, migrate_1.isThereAWarning)(generateTemplateOutput)) {
                (0, logging_1.warning)(' ⚠️  Some resources could not be migrated completely. Please review the README.md file for more information.');
                (0, migrate_1.appendWarningsToReadme)(`${path.join(options.outputPath ?? process.cwd(), options.stackName)}/README.md`, generateTemplateOutput.resources);
            }
        }
        catch (e) {
            (0, logging_1.error)(' ❌  Migrate failed for `%s`: %s', options.stackName, e.message);
            throw e;
        }
        finally {
            if (templateToDelete) {
                if (!cfn) {
                    cfn = new migrate_1.CfnTemplateGeneratorProvider(await (0, migrate_1.buildCfnClient)(this.props.sdkProvider, environment));
                }
                if (!process.env.MIGRATE_INTEG_TEST) {
                    await cfn.deleteGeneratedTemplate(templateToDelete);
                }
            }
        }
    }
    async refactor(options) {
        let exclude = [];
        if (options.excludeFile != null) {
            if (!(await fs.pathExists(options.excludeFile))) {
                throw new toolkit_lib_1.ToolkitError(`The exclude file '${options.excludeFile}' does not exist`);
            }
            exclude = fs.readFileSync(options.excludeFile).toString('utf-8').split('\n');
        }
        try {
            await this.toolkit.refactor(this.props.cloudExecutable, {
                dryRun: options.dryRun,
                exclude,
                stacks: {
                    patterns: options.selector.patterns,
                    strategy: options.selector.patterns.length > 0 ? toolkit_lib_1.StackSelectionStrategy.PATTERN_MATCH : toolkit_lib_1.StackSelectionStrategy.ALL_STACKS,
                },
            });
        }
        catch (e) {
            (0, logging_1.error)(e.message);
            return 1;
        }
        return 0;
    }
    async selectStacksForList(patterns) {
        const assembly = await this.assembly();
        const stacks = await assembly.selectStacks({ patterns }, { defaultBehavior: cxapp_1.DefaultSelection.AllStacks });
        // No validation
        return stacks;
    }
    async selectStacksForDeploy(selector, exclusively, cacheCloudAssembly, ignoreNoStacks) {
        const assembly = await this.assembly(cacheCloudAssembly);
        const stacks = await assembly.selectStacks(selector, {
            extend: exclusively ? cloud_assembly_1.ExtendedStackSelection.None : cloud_assembly_1.ExtendedStackSelection.Upstream,
            defaultBehavior: cxapp_1.DefaultSelection.OnlySingle,
            ignoreNoStacks,
        });
        this.validateStacksSelected(stacks, selector.patterns);
        await this.validateStacks(stacks);
        return stacks;
    }
    async selectStacksForDiff(stackNames, exclusively, autoValidate) {
        const assembly = await this.assembly();
        const selectedForDiff = await assembly.selectStacks({ patterns: stackNames }, {
            extend: exclusively ? cloud_assembly_1.ExtendedStackSelection.None : cloud_assembly_1.ExtendedStackSelection.Upstream,
            defaultBehavior: cxapp_1.DefaultSelection.MainAssembly,
        });
        const allStacks = await this.selectStacksForList([]);
        const autoValidateStacks = autoValidate
            ? allStacks.filter((art) => art.validateOnSynth ?? false)
            : new cloud_assembly_1.StackCollection(assembly, []);
        this.validateStacksSelected(selectedForDiff.concat(autoValidateStacks), stackNames);
        await this.validateStacks(selectedForDiff.concat(autoValidateStacks));
        return selectedForDiff;
    }
    async selectStacksForDestroy(selector, exclusively) {
        const assembly = await this.assembly();
        const stacks = await assembly.selectStacks(selector, {
            extend: exclusively ? cloud_assembly_1.ExtendedStackSelection.None : cloud_assembly_1.ExtendedStackSelection.Downstream,
            defaultBehavior: cxapp_1.DefaultSelection.OnlySingle,
        });
        // No validation
        return stacks;
    }
    /**
     * Validate the stacks for errors and warnings according to the CLI's current settings
     */
    async validateStacks(stacks) {
        const failAt = this.validateMetadataFailAt();
        await stacks.validateMetadata(failAt, stackMetadataLogger(this.props.verbose));
    }
    validateMetadataFailAt() {
        let failAt = 'error';
        if (this.props.ignoreErrors) {
            failAt = 'none';
        }
        if (this.props.strict) {
            failAt = 'warn';
        }
        return failAt;
    }
    /**
     * Validate that if a user specified a stack name there exists at least 1 stack selected
     */
    validateStacksSelected(stacks, stackNames) {
        if (stackNames.length != 0 && stacks.stackCount == 0) {
            throw new toolkit_lib_1.ToolkitError(`No stacks match the name(s) ${stackNames}`);
        }
    }
    /**
     * Select a single stack by its name
     */
    async selectSingleStackByName(stackName) {
        const assembly = await this.assembly();
        const stacks = await assembly.selectStacks({ patterns: [stackName] }, {
            extend: cloud_assembly_1.ExtendedStackSelection.None,
            defaultBehavior: cxapp_1.DefaultSelection.None,
        });
        // Could have been a glob so check that we evaluated to exactly one
        if (stacks.stackCount > 1) {
            throw new toolkit_lib_1.ToolkitError(`This command requires exactly one stack and we matched more than one: ${stacks.stackIds}`);
        }
        return assembly.stackById(stacks.firstStack.id);
    }
    assembly(cacheCloudAssembly) {
        return this.props.cloudExecutable.synthesize(cacheCloudAssembly);
    }
    patternsArrayForWatch(patterns, options) {
        const patternsArray = patterns !== undefined ? (Array.isArray(patterns) ? patterns : [patterns]) : [];
        return patternsArray.length > 0 ? patternsArray : options.returnRootDirIfEmpty ? [options.rootDir] : [];
    }
    async invokeDeployFromWatch(options, cloudWatchLogMonitor) {
        const deployOptions = {
            ...options,
            requireApproval: diff_1.RequireApproval.NEVER,
            // if 'watch' is called by invoking 'cdk deploy --watch',
            // we need to make sure to not call 'deploy' with 'watch' again,
            // as that would lead to a cycle
            watch: false,
            cloudWatchLogMonitor,
            cacheCloudAssembly: false,
            hotswap: options.hotswap,
            extraUserAgent: `cdk-watch/hotswap-${options.hotswap !== hotswap_1.HotswapMode.FALL_BACK ? 'on' : 'off'}`,
            concurrency: options.concurrency,
        };
        try {
            await this.deploy(deployOptions);
        }
        catch {
            // just continue - deploy will show the error
        }
    }
    /**
     * Remove the asset publishing and building from the work graph for assets that are already in place
     */
    async removePublishedAssets(graph, options) {
        await graph.removeUnnecessaryAssets(assetNode => this.props.deployments.isSingleAssetPublished(assetNode.assetManifest, assetNode.asset, {
            stack: assetNode.parentStack,
            roleArn: options.roleArn,
            stackName: assetNode.parentStack.stackName,
        }));
    }
}
exports.CdkToolkit = CdkToolkit;
/**
 * Print a serialized object (YAML or JSON) to stdout.
 */
function printSerializedObject(obj, json) {
    (0, logging_1.result)((0, util_2.serializeStructure)(obj, json));
}
function buildParameterMap(parameters) {
    const parameterMap = { '*': {} };
    for (const key in parameters) {
        if (parameters.hasOwnProperty(key)) {
            const [stack, parameter] = key.split(':', 2);
            if (!parameter) {
                parameterMap['*'][stack] = parameters[key];
            }
            else {
                if (!parameterMap[stack]) {
                    parameterMap[stack] = {};
                }
                parameterMap[stack][parameter] = parameters[key];
            }
        }
    }
    return parameterMap;
}
/**
 * Ask the user for a yes/no confirmation
 *
 * Automatically fail the confirmation in case we're in a situation where the confirmation
 * cannot be interactively obtained from a human at the keyboard.
 */
async function askUserConfirmation(ioHost, concurrency, motivation, question) {
    await ioHost.withCorkedLogging(async () => {
        // only talk to user if STDIN is a terminal (otherwise, fail)
        if (!TESTING && !process.stdin.isTTY) {
            throw new toolkit_lib_1.ToolkitError(`${motivation}, but terminal (TTY) is not attached so we are unable to get a confirmation from the user`);
        }
        // only talk to user if concurrency is 1 (otherwise, fail)
        if (concurrency > 1) {
            throw new toolkit_lib_1.ToolkitError(`${motivation}, but concurrency is greater than 1 so we are unable to get a confirmation from the user`);
        }
        const confirmed = await promptly.confirm(`${chalk.cyan(question)} (y/n)?`);
        if (!confirmed) {
            throw new toolkit_lib_1.ToolkitError('Aborted by user');
        }
    });
}
/**
 * Logger for processing stack metadata
 */
function stackMetadataLogger(verbose) {
    const makeLogger = (level) => {
        switch (level) {
            case 'error':
                return [logging_1.error, 'Error'];
            case 'warn':
                return [logging_1.warning, 'Warning'];
            default:
                return [logging_1.info, 'Info'];
        }
    };
    return async (level, msg) => {
        const [logFn, prefix] = makeLogger(level);
        logFn(`[${prefix} at ${msg.id}] ${msg.entry.data}`);
        if (verbose && msg.entry.trace) {
            logFn(`  ${msg.entry.trace.join('\n  ')}`);
        }
    };
}
/**
 * Determine if manual approval is required or not. Requires approval for
 * - RequireApproval.ANY_CHANGE
 * - RequireApproval.BROADENING and the changes are indeed broadening permissions
 */
function requiresApproval(requireApproval, permissionChangeType) {
    return requireApproval === diff_1.RequireApproval.ANY_CHANGE ||
        requireApproval === diff_1.RequireApproval.BROADENING && permissionChangeType === payloads_1.PermissionChangeType.BROADENING;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrLXRvb2xraXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjZGstdG9vbGtpdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFzRUEsa0NBRUM7QUF4RUQsNkJBQTZCO0FBQzdCLCtCQUE4QjtBQUM5Qix5Q0FBeUM7QUFDekMsK0JBQStCO0FBQy9CLHFDQUFxQztBQUNyQywrQkFBK0I7QUFDL0IscUNBQXFDO0FBQ3JDLDZCQUE2QjtBQUM3Qix1Q0FBc0M7QUFFdEMsNkRBQXNEO0FBQ3RELCtEQUFxRjtBQUVyRiw4RUFBOEU7QUFDOUUseUVBQWtGO0FBRWxGLHVFQUFvRTtBQUNwRSxnQ0FBb0Q7QUFHcEQsZ0RBQWdEO0FBQ2hELDBEQUFnRjtBQUVoRixrRUFBNkQ7QUFDN0QsNENBQTZGO0FBQzdGLHNEQUF5RjtBQUN6Riw0REFBc0c7QUFDdEcsc0NBQXFEO0FBRXJELGtEQUFxRDtBQUNyRCxnREFBd0M7QUFDeEMsK0NBQTJEO0FBQzNELDJDQUFrRTtBQUNsRSx5REFBcUQ7QUFFckQsaURBZTZCO0FBRTdCLG9DQUFvSDtBQUNwSCx3Q0FBa0c7QUFDbEcsa0NBUWlCO0FBRWpCLDZFQUE2RTtBQUM3RSw0R0FBNEc7QUFDNUcsTUFBTSxNQUFNLEdBQTZCLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUU1RCxJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUM7QUFFcEIsU0FBZ0IsV0FBVztJQUN6QixPQUFPLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLENBQUM7QUF5REQ7O0dBRUc7QUFDSCxJQUFZLGNBYVg7QUFiRCxXQUFZLGNBQWM7SUFDeEI7Ozs7O09BS0c7SUFDSCx5REFBdUMsQ0FBQTtJQUV2Qzs7T0FFRztJQUNILCtDQUE2QixDQUFBO0FBQy9CLENBQUMsRUFiVyxjQUFjLDhCQUFkLGNBQWMsUUFhekI7QUFFRCxNQUFNLGVBQWdCLFNBQVEsaUJBQU87SUFFbkMsWUFBbUIsV0FBd0IsRUFBRSxPQUF1QjtRQUNsRSxLQUFLLENBQUMsT0FBTyxD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dCI6WyJpbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0ICogYXMgY2hva2lkYXIgZnJvbSAnY2hva2lkYXInO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgcHJvbXB0bHkgZnJvbSAncHJvbXB0bHknO1xuaW1wb3J0ICogYXMgdXVpZCBmcm9tICd1dWlkJztcbmltcG9ydCB7IENsaUlvSG9zdCB9IGZyb20gJy4vaW8taG9zdCc7XG5pbXBvcnQgdHlwZSB7IENvbmZpZ3VyYXRpb24gfSBmcm9tICcuL3VzZXItY29uZmlndXJhdGlvbic7XG5pbXBvcnQgeyBQUk9KRUNUX0NPTkZJRyB9IGZyb20gJy4vdXNlci1jb25maWd1cmF0aW9uJztcbmltcG9ydCB7IFN0YWNrU2VsZWN0aW9uU3RyYXRlZ3ksIFRvb2xraXRFcnJvciB9IGZyb20gJy4uLy4uLy4uL0Bhd3MtY2RrL3Rvb2xraXQtbGliJztcbmltcG9ydCB0eXBlIHsgVG9vbGtpdEFjdGlvbiB9IGZyb20gJy4uLy4uLy4uL0Bhd3MtY2RrL3Rvb2xraXQtbGliL2xpYi9hcGknO1xuaW1wb3J0IHsgYXNJb0hlbHBlciB9IGZyb20gJy4uLy4uLy4uL0Bhd3MtY2RrL3Rvb2xraXQtbGliL2xpYi9hcGkvaW8vcHJpdmF0ZSc7XG5pbXBvcnQgeyBQZXJtaXNzaW9uQ2hhbmdlVHlwZSB9IGZyb20gJy4uLy4uLy4uL0Bhd3MtY2RrL3Rvb2xraXQtbGliL2xpYi9wYXlsb2Fkcyc7XG5pbXBvcnQgdHlwZSB7IFRvb2xraXRPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vQGF3cy1jZGsvdG9vbGtpdC1saWIvbGliL3Rvb2xraXQnO1xuaW1wb3J0IHsgVG9vbGtpdCB9IGZyb20gJy4uLy4uLy4uL0Bhd3MtY2RrL3Rvb2xraXQtbGliL2xpYi90b29sa2l0JztcbmltcG9ydCB7IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FIH0gZnJvbSAnLi4vYXBpJztcbmltcG9ydCB0eXBlIHsgU2RrUHJvdmlkZXIgfSBmcm9tICcuLi9hcGkvYXdzLWF1dGgnO1xuaW1wb3J0IHR5cGUgeyBCb290c3RyYXBFbnZpcm9ubWVudE9wdGlvbnMgfSBmcm9tICcuLi9hcGkvYm9vdHN0cmFwJztcbmltcG9ydCB7IEJvb3RzdHJhcHBlciB9IGZyb20gJy4uL2FwaS9ib290c3RyYXAnO1xuaW1wb3J0IHsgRXh0ZW5kZWRTdGFja1NlbGVjdGlvbiwgU3RhY2tDb2xsZWN0aW9uIH0gZnJvbSAnLi4vYXBpL2Nsb3VkLWFzc2VtYmx5JztcbmltcG9ydCB0eXBlIHsgRGVwbG95bWVudE1ldGhvZCwgRGVwbG95bWVudHMsIFN1Y2Nlc3NmdWxEZXBsb3lTdGFja1Jlc3VsdCB9IGZyb20gJy4uL2FwaS9kZXBsb3ltZW50cyc7XG5pbXBvcnQgeyBHYXJiYWdlQ29sbGVjdG9yIH0gZnJvbSAnLi4vYXBpL2dhcmJhZ2UtY29sbGVjdGlvbic7XG5pbXBvcnQgeyBFY3NIb3Rzd2FwUHJvcGVydGllcywgSG90c3dhcE1vZGUsIEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyB9IGZyb20gJy4uL2FwaS9ob3Rzd2FwJztcbmltcG9ydCB7IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IsIGZpbmRDbG91ZFdhdGNoTG9nR3JvdXBzIH0gZnJvbSAnLi4vYXBpL2xvZ3MtbW9uaXRvcic7XG5pbXBvcnQgeyByZW1vdmVOb25JbXBvcnRSZXNvdXJjZXMsIFJlc291cmNlSW1wb3J0ZXIsIFJlc291cmNlTWlncmF0b3IgfSBmcm9tICcuLi9hcGkvcmVzb3VyY2UtaW1wb3J0JztcbmltcG9ydCB7IHR5cGUgVGFnLCB0YWdzRm9yU3RhY2sgfSBmcm9tICcuLi9hcGkvdGFncyc7XG5pbXBvcnQgdHlwZSB7IEFzc2V0QnVpbGROb2RlLCBBc3NldFB1Ymxpc2hOb2RlLCBDb25jdXJyZW5jeSwgU3RhY2tOb2RlLCBXb3JrR3JhcGggfSBmcm9tICcuLi9hcGkvd29yay1ncmFwaCc7XG5pbXBvcnQgeyBXb3JrR3JhcGhCdWlsZGVyIH0gZnJvbSAnLi4vYXBpL3dvcmstZ3JhcGgnO1xuaW1wb3J0IHsgY2ZuQXBpIH0gZnJvbSAnLi4vYXBpLXByaXZhdGUnO1xuaW1wb3J0IHsgU3RhY2tBY3Rpdml0eVByb2dyZXNzIH0gZnJvbSAnLi4vY29tbWFuZHMvZGVwbG95JztcbmltcG9ydCB7IERpZmZGb3JtYXR0ZXIsIFJlcXVpcmVBcHByb3ZhbCB9IGZyb20gJy4uL2NvbW1hbmRzL2RpZmYnO1xuaW1wb3J0IHsgbGlzdFN0YWNrcyB9IGZyb20gJy4uL2NvbW1hbmRzL2xpc3Qtc3RhY2tzJztcbmltcG9ydCB0eXBlIHsgRnJvbVNjYW4sIEdlbmVyYXRlVGVtcGxhdGVPdXRwdXQgfSBmcm9tICcuLi9jb21tYW5kcy9taWdyYXRlJztcbmltcG9ydCB7XG4gIGFwcGVuZFdhcm5pbmdzVG9SZWFkbWUsXG4gIGJ1aWxkQ2ZuQ2xpZW50LFxuICBidWlsZEdlbmVydGVkVGVtcGxhdGVPdXRwdXQsXG4gIENmblRlbXBsYXRlR2VuZXJhdG9yUHJvdmlkZXIsXG4gIGdlbmVyYXRlQ2RrQXBwLFxuICBnZW5lcmF0ZVN0YWNrLFxuICBnZW5lcmF0ZVRlbXBsYXRlLFxuICBpc1RoZXJlQVdhcm5pbmcsXG4gIHBhcnNlU291cmNlT3B0aW9ucyxcbiAgcmVhZEZyb21QYXRoLFxuICByZWFkRnJvbVN0YWNrLFxuICBzZXRFbnZpcm9ubWVudCxcbiAgVGVtcGxhdGVTb3VyY2VPcHRpb25zLFxuICB3cml0ZU1pZ3JhdGVKc29uRmlsZSxcbn0gZnJvbSAnLi4vY29tbWFuZHMvbWlncmF0ZSc7XG5pbXBvcnQgdHlwZSB7IENsb3VkQXNzZW1ibHksIENsb3VkRXhlY3V0YWJsZSwgU3RhY2tTZWxlY3RvciB9IGZyb20gJy4uL2N4YXBwJztcbmltcG9ydCB7IERlZmF1bHRTZWxlY3Rpb24sIGVudmlyb25tZW50c0Zyb21EZXNjcmlwdG9ycywgZ2xvYkVudmlyb25tZW50c0Zyb21TdGFja3MsIGxvb2tzTGlrZUdsb2IgfSBmcm9tICcuLi9jeGFwcCc7XG5pbXBvcnQgeyBkZWJ1ZywgZXJyb3IsIGhpZ2hsaWdodCwgaW5mbywgcmVzdWx0IGFzIGxvZ1Jlc3VsdCwgc3VjY2Vzcywgd2FybmluZyB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHtcbiAgZGVzZXJpYWxpemVTdHJ1Y3R1cmUsXG4gIGZvcm1hdEVycm9yTWVzc2FnZSxcbiAgZm9ybWF0VGltZSxcbiAgb2JzY3VyZVRlbXBsYXRlLFxuICBwYXJ0aXRpb24sXG4gIHNlcmlhbGl6ZVN0cnVjdHVyZSxcbiAgdmFsaWRhdGVTbnNUb3BpY0Fybixcbn0gZnJvbSAnLi4vdXRpbCc7XG5cbi8vIE11c3QgdXNlIGEgcmVxdWlyZSgpIG90aGVyd2lzZSBlc2J1aWxkIGNvbXBsYWlucyBhYm91dCBjYWxsaW5nIGEgbmFtZXNwYWNlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyxAdHlwZXNjcmlwdC1lc2xpbnQvY29uc2lzdGVudC10eXBlLWltcG9ydHNcbmNvbnN0IHBMaW1pdDogdHlwZW9mIGltcG9ydCgncC1saW1pdCcpID0gcmVxdWlyZSgncC1saW1pdCcpO1xuXG5sZXQgVEVTVElORyA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gbWFya1Rlc3RpbmcoKSB7XG4gIFRFU1RJTkcgPSB0cnVlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENka1Rvb2xraXRQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgQ2xvdWQgRXhlY3V0YWJsZVxuICAgKi9cbiAgY2xvdWRFeGVjdXRhYmxlOiBDbG91ZEV4ZWN1dGFibGU7XG5cbiAgLyoqXG4gICAqIFRoZSBwcm92aXNpb25pbmcgZW5naW5lIHVzZWQgdG8gYXBwbHkgY2hhbmdlcyB0byB0aGUgY2xvdWRcbiAgICovXG4gIGRlcGxveW1lbnRzOiBEZXBsb3ltZW50cztcblxuICAvKipcbiAgICogVGhlIENsaUlvSG9zdCB0aGF0J3MgdXNlZCBmb3IgSS9PIG9wZXJhdGlvbnNcbiAgICovXG4gIGlvSG9zdD86IENsaUlvSG9zdDtcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgdG9vbGtpdCBzdGFjayB0byB1c2UvZGVwbG95XG4gICAqXG4gICAqIEBkZWZhdWx0IENES1Rvb2xraXRcbiAgICovXG4gIHRvb2xraXRTdGFja05hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYmUgdmVyYm9zZVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgdmVyYm9zZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERvbid0IHN0b3Agb24gZXJyb3IgbWV0YWRhdGFcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGlnbm9yZUVycm9ycz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRyZWF0IHdhcm5pbmdzIGluIG1ldGFkYXRhIGFzIGVycm9yc1xuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgc3RyaWN0PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQXBwbGljYXRpb24gY29uZmlndXJhdGlvbiAoc2V0dGluZ3MgYW5kIGNvbnRleHQpXG4gICAqL1xuICBjb25maWd1cmF0aW9uOiBDb25maWd1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBBV1Mgb2JqZWN0ICh1c2VkIGJ5IHN5bnRoZXNpemVyIGFuZCBjb250ZXh0cHJvdmlkZXIpXG4gICAqL1xuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXI7XG59XG5cbi8qKlxuICogV2hlbiB0byBidWlsZCBhc3NldHNcbiAqL1xuZXhwb3J0IGVudW0gQXNzZXRCdWlsZFRpbWUge1xuICAvKipcbiAgICogQnVpbGQgYWxsIGFzc2V0cyBiZWZvcmUgZGVwbG95aW5nIHRoZSBmaXJzdCBzdGFja1xuICAgKlxuICAgKiBUaGlzIGlzIGludGVuZGVkIGZvciBleHBlbnNpdmUgRG9ja2VyIGltYWdlIGJ1aWxkczsgc28gdGhhdCBpZiB0aGUgRG9ja2VyIGltYWdlIGJ1aWxkXG4gICAqIGZhaWxzLCBubyBzdGFja3MgYXJlIHVubmVjZXNzYXJpbHkgZGVwbG95ZWQgKHdpdGggdGhlIGF0dGVuZGFudCB3YWl0IHRpbWUpLlxuICAgKi9cbiAgQUxMX0JFRk9SRV9ERVBMT1kgPSAnYWxsLWJlZm9yZS1kZXBsb3knLFxuXG4gIC8qKlxuICAgKiBCdWlsZCBhc3NldHMganVzdC1pbi10aW1lLCBiZWZvcmUgcHVibGlzaGluZ1xuICAgKi9cbiAgSlVTVF9JTl9USU1FID0gJ2p1c3QtaW4tdGltZScsXG59XG5cbmNsYXNzIEludGVybmFsVG9vbGtpdCBleHRlbmRzIFRvb2xraXQge1xuICBwcml2YXRlIHJlYWRvbmx5IF9zZGtQcm92aWRlcjogU2RrUHJvdmlkZXI7XG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsIG9wdGlvbnM6IFRvb2xraXRPcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5fc2RrUHJvdmlkZXIgPSBzZGtQcm92aWRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2Nlc3MgdG8gdGhlIEFXUyBTREtcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgc2RrUHJvdmlkZXIoX2FjdGlvbjogVG9vbGtpdEFjdGlvbik6IFByb21pc2U8U2RrUHJvdmlkZXI+IHtcbiAgICByZXR1cm4gdGhpcy5fc2RrUHJvdmlkZXI7XG4gIH1cbn1cblxuLyoqXG4gKiBUb29sa2l0IGxvZ2ljXG4gKlxuICogVGhlIHRvb2xraXQgcnVucyB0aGUgYGNsb3VkRXhlY3V0YWJsZWAgdG8gb2J0YWluIGEgY2xvdWQgYXNzZW1ibHkgYW5kXG4gKiBkZXBsb3lzIGFwcGxpZXMgdGhlbSB0byBgY2xvdWRGb3JtYXRpb25gLlxuICovXG5leHBvcnQgY2xhc3MgQ2RrVG9vbGtpdCB7XG4gIHByaXZhdGUgaW9Ib3N0OiBDbGlJb0hvc3Q7XG4gIHByaXZhdGUgdG9vbGtpdFN0YWNrTmFtZTogc3RyaW5nO1xuICBwcml2YXRlIHRvb2xraXQ6IEludGVybmFsVG9vbGtpdDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb3BzOiBDZGtUb29sa2l0UHJvcHMpIHtcbiAgICB0aGlzLmlvSG9zdCA9IHByb3BzLmlvSG9zdCA/PyBDbGlJb0hvc3QuaW5zdGFuY2UoKTtcbiAgICB0aGlzLnRvb2xraXRTdGFja05hbWUgPSBwcm9wcy50b29sa2l0U3RhY2tOYW1lID8/IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FO1xuXG4gICAgdGhpcy50b29sa2l0ID0gbmV3IEludGVybmFsVG9vbGtpdChwcm9wcy5zZGtQcm92aWRlciwge1xuICAgICAgYXNzZW1ibHlGYWlsdXJlQXQ6IHRoaXMudmFsaWRhdGVNZXRhZGF0YUZhaWxBdCgpLFxuICAgICAgY29sb3I6IHRydWUsXG4gICAgICBlbW9qaXM6IHRydWUsXG4gICAgICBpb0hvc3Q6IHRoaXMuaW9Ib3N0LFxuICAgICAgc2RrQ29uZmlnOiB7fSxcbiAgICAgIHRvb2xraXRTdGFja05hbWU6IHRoaXMudG9vbGtpdFN0YWNrTmFtZSxcbiAgICB9KTtcbiAgICB0aGlzLnRvb2xraXQ7IC8vIGFyaXRpZmljYWwgdXNlIG9mIHRoaXMudG9vbGtpdCB0byBzYXRpc2Z5IFRTLCB3ZSB3YW50IHRvIHByZXBhcmUgdXNhZ2Ugb2YgdGhlIG5ldyB0b29sa2l0IHdpdGhvdXQgdXNpbmcgaXQganVzdCB5ZXRcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBtZXRhZGF0YShzdGFja05hbWU6IHN0cmluZywganNvbjogYm9vbGVhbikge1xuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IHRoaXMuc2VsZWN0U2luZ2xlU3RhY2tCeU5hbWUoc3RhY2tOYW1lKTtcbiAgICBwcmludFNlcmlhbGl6ZWRPYmplY3Qoc3RhY2tzLmZpcnN0U3RhY2subWFuaWZlc3QubWV0YWRhdGEgPz8ge30sIGpzb24pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGFja25vd2xlZGdlKG5vdGljZUlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBhY2tzID0gdGhpcy5wcm9wcy5jb25maWd1cmF0aW9uLmNvbnRleHQuZ2V0KCdhY2tub3dsZWRnZWQtaXNzdWUtbnVtYmVycycpID8/IFtdO1xuICAgIGFja3MucHVzaChOdW1iZXIobm90aWNlSWQpKTtcbiAgICB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24uY29udGV4dC5zZXQoJ2Fja25vd2xlZGdlZC1pc3N1ZS1udW1iZXJzJywgYWNrcyk7XG4gICAgYXdhaXQgdGhpcy5wcm9wcy5jb25maWd1cmF0aW9uLnNhdmVDb250ZXh0KCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGlmZihvcHRpb25zOiBEaWZmT3B0aW9ucyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgdGhpcy5zZWxlY3RTdGFja3NGb3JEaWZmKG9wdGlvbnMuc3RhY2tOYW1lcywgb3B0aW9ucy5leGNsdXNpdmVseSk7XG5cbiAgICBjb25zdCBzdHJpY3QgPSAhIW9wdGlvbnMuc3RyaWN0O1xuICAgIGNvbnN0IGNvbnRleHRMaW5lcyA9IG9wdGlvbnMuY29udGV4dExpbmVzIHx8IDM7XG4gICAgY29uc3QgcXVpZXQgPSBvcHRpb25zLnF1aWV0IHx8IGZhbHNlO1xuXG4gICAgbGV0IGRpZmZzID0gMDtcbiAgICBjb25zdCBwYXJhbWV0ZXJNYXAgPSBidWlsZFBhcmFtZXRlck1hcChvcHRpb25zLnBhcmFtZXRlcnMpO1xuXG4gICAgaWYgKG9wdGlvbnMudGVtcGxhdGVQYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIENvbXBhcmUgc2luZ2xlIHN0YWNrIGFnYWluc3QgZml4ZWQgdGVtcGxhdGVcbiAgICAgIGlmIChzdGFja3Muc3RhY2tDb3VudCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgICAgICdDYW4gb25seSBzZWxlY3Qgb25lIHN0YWNrIHdoZW4gY29tcGFyaW5nIHRvIGZpeGVkIHRlbXBsYXRlLiBVc2UgLS1leGNsdXNpdmVseSB0byBhdm9pZCBzZWxlY3RpbmcgbXVsdGlwbGUgc3RhY2tzLicsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghKGF3YWl0IGZzLnBhdGhFeGlzdHMob3B0aW9ucy50ZW1wbGF0ZVBhdGgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBUaGVyZSBpcyBubyBmaWxlIGF0ICR7b3B0aW9ucy50ZW1wbGF0ZVBhdGh9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gZGVzZXJpYWxpemVTdHJ1Y3R1cmUoYXdhaXQgZnMucmVhZEZpbGUob3B0aW9ucy50ZW1wbGF0ZVBhdGgsIHsgZW5jb2Rpbmc6ICdVVEYtOCcgfSkpO1xuICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IERpZmZGb3JtYXR0ZXIoe1xuICAgICAgICBpb0hlbHBlcjogYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ2RpZmYnKSxcbiAgICAgICAgdGVtcGxhdGVJbmZvOiB7XG4gICAgICAgICAgb2xkVGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgICAgIG5ld1RlbXBsYXRlOiBzdGFja3MuZmlyc3RTdGFjayxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob3B0aW9ucy5zZWN1cml0eU9ubHkpIHtcbiAgICAgICAgY29uc3Qgc2VjdXJpdHlEaWZmID0gZm9ybWF0dGVyLmZvcm1hdFNlY3VyaXR5RGlmZigpO1xuICAgICAgICAvLyBXYXJuLCBjb3VudCwgYW5kIGRpc3BsYXkgdGhlIGRpZmYgb25seSBpZiB0aGUgcmVwb3J0ZWQgY2hhbmdlcyBhcmUgYnJvYWRlbmluZyBwZXJtaXNzaW9uc1xuICAgICAgICBpZiAoc2VjdXJpdHlEaWZmLnBlcm1pc3Npb25DaGFuZ2VUeXBlID09PSBQZXJtaXNzaW9uQ2hhbmdlVHlwZS5CUk9BREVOSU5HKSB7XG4gICAgICAgICAgd2FybmluZygnVGhpcyBkZXBsb3ltZW50IHdpbGwgbWFrZSBwb3RlbnRpYWxseSBzZW5zaXRpdmUgY2hhbmdlcyBhY2NvcmRpbmcgdG8geW91ciBjdXJyZW50IHNlY3VyaXR5IGFwcHJvdmFsIGxldmVsLlxcblBsZWFzZSBjb25maXJtIHlvdSBpbnRlbmQgdG8gbWFrZSB0aGUgZm9sbG93aW5nIG1vZGlmaWNhdGlvbnM6XFxuJyk7XG4gICAgICAgICAgaW5mbyhzZWN1cml0eURpZmYuZm9ybWF0dGVkRGlmZik7XG4gICAgICAgICAgZGlmZnMgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGlmZiA9IGZvcm1hdHRlci5mb3JtYXRTdGFja0RpZmYoe1xuICAgICAgICAgIHN0cmljdCxcbiAgICAgICAgICBjb250ZXh0OiBjb250ZXh0TGluZXMsXG4gICAgICAgICAgcXVpZXQsXG4gICAgICAgIH0pO1xuICAgICAgICBkaWZmcyA9IGRpZmYubnVtU3RhY2tzV2l0aENoYW5nZXM7XG4gICAgICAgIGluZm8oZGlmZi5mb3JtYXR0ZWREaWZmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29tcGFyZSBOIHN0YWNrcyBhZ2FpbnN0IGRlcGxveWVkIHRlbXBsYXRlc1xuICAgICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja3Muc3RhY2tBcnRpZmFjdHMpIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVXaXRoTmVzdGVkU3RhY2tzID0gYXdhaXQgdGhpcy5wcm9wcy5kZXBsb3ltZW50cy5yZWFkQ3VycmVudFRlbXBsYXRlV2l0aE5lc3RlZFN0YWNrcyhcbiAgICAgICAgICBzdGFjayxcbiAgICAgICAgICBvcHRpb25zLmNvbXBhcmVBZ2FpbnN0UHJvY2Vzc2VkVGVtcGxhdGUsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUZW1wbGF0ZSA9IHRlbXBsYXRlV2l0aE5lc3RlZFN0YWNrcy5kZXBsb3llZFJvb3RUZW1wbGF0ZTtcbiAgICAgICAgY29uc3QgbmVzdGVkU3RhY2tzID0gdGVtcGxhdGVXaXRoTmVzdGVkU3RhY2tzLm5lc3RlZFN0YWNrcztcblxuICAgICAgICBjb25zdCBtaWdyYXRvciA9IG5ldyBSZXNvdXJjZU1pZ3JhdG9yKHtcbiAgICAgICAgICBkZXBsb3ltZW50czogdGhpcy5wcm9wcy5kZXBsb3ltZW50cyxcbiAgICAgICAgICBpb0hlbHBlcjogYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ2RpZmYnKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc291cmNlc1RvSW1wb3J0ID0gYXdhaXQgbWlncmF0b3IudHJ5R2V0UmVzb3VyY2VzKGF3YWl0IHRoaXMucHJvcHMuZGVwbG95bWVudHMucmVzb2x2ZUVudmlyb25tZW50KHN0YWNrKSk7XG4gICAgICAgIGlmIChyZXNvdXJjZXNUb0ltcG9ydCkge1xuICAgICAgICAgIHJlbW92ZU5vbkltcG9ydFJlc291cmNlcyhzdGFjayk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2hhbmdlU2V0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmNoYW5nZVNldCkge1xuICAgICAgICAgIGxldCBzdGFja0V4aXN0cyA9IGZhbHNlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGFja0V4aXN0cyA9IGF3YWl0IHRoaXMucHJvcHMuZGVwbG95bWVudHMuc3RhY2tFeGlzdHMoe1xuICAgICAgICAgICAgICBzdGFjayxcbiAgICAgICAgICAgICAgZGVwbG95TmFtZTogc3RhY2suc3RhY2tOYW1lLFxuICAgICAgICAgICAgICB0cnlMb29rdXBSb2xlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICBkZWJ1Zyhmb3JtYXRFcnJvck1lc3NhZ2UoZSkpO1xuICAgICAgICAgICAgaWYgKCFxdWlldCkge1xuICAgICAgICAgICAgICBpbmZvKFxuICAgICAgICAgICAgICAgIGBDaGVja2luZyBpZiB0aGUgc3RhY2sgJHtzdGFjay5zdGFja05hbWV9IGV4aXN0cyBiZWZvcmUgY3JlYXRpbmcgdGhlIGNoYW5nZXNldCBoYXMgZmFpbGVkLCB3aWxsIGJhc2UgdGhlIGRpZmYgb24gdGVtcGxhdGUgZGlmZmVyZW5jZXMgKHJ1biBhZ2FpbiB3aXRoIC12IHRvIHNlZSB0aGUgcmVhc29uKVxcbmAsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFja0V4aXN0cyA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGFja0V4aXN0cykge1xuICAgICAgICAgICAgY2hhbmdlU2V0ID0gYXdhaXQgY2ZuQXBpLmNyZWF0ZURpZmZDaGFuZ2VTZXQoYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ2RpZmYnKSwge1xuICAgICAgICAgICAgICBzdGFjayxcbiAgICAgICAgICAgICAgdXVpZDogdXVpZC52NCgpLFxuICAgICAgICAgICAgICBkZXBsb3ltZW50czogdGhpcy5wcm9wcy5kZXBsb3ltZW50cyxcbiAgICAgICAgICAgICAgd2lsbEV4ZWN1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICBzZGtQcm92aWRlcjogdGhpcy5wcm9wcy5zZGtQcm92aWRlcixcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1ldGVyTWFwWycqJ10sIHBhcmFtZXRlck1hcFtzdGFjay5zdGFja05hbWVdKSxcbiAgICAgICAgICAgICAgcmVzb3VyY2VzVG9JbXBvcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXG4gICAgICAgICAgICAgIGB0aGUgc3RhY2sgJyR7c3RhY2suc3RhY2tOYW1lfScgaGFzIG5vdCBiZWVuIGRlcGxveWVkIHRvIENsb3VkRm9ybWF0aW9uIG9yIGRlc2NyaWJlU3RhY2tzIGNhbGwgZmFpbGVkLCBza2lwcGluZyBjaGFuZ2VzZXQgY3JlYXRpb24uYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IERpZmZGb3JtYXR0ZXIoe1xuICAgICAgICAgIGlvSGVscGVyOiBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCAnZGlmZicpLFxuICAgICAgICAgIHRlbXBsYXRlSW5mbzoge1xuICAgICAgICAgICAgb2xkVGVtcGxhdGU6IGN1cnJlbnRUZW1wbGF0ZSxcbiAgICAgICAgICAgIG5ld1RlbXBsYXRlOiBzdGFjayxcbiAgICAgICAgICAgIGNoYW5nZVNldCxcbiAgICAgICAgICAgIGlzSW1wb3J0OiAhIXJlc291cmNlc1RvSW1wb3J0LFxuICAgICAgICAgICAgbmVzdGVkU3RhY2tzLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNlY3VyaXR5T25seSkge1xuICAgICAgICAgIGNvbnN0IHNlY3VyaXR5RGlmZiA9IGZvcm1hdHRlci5mb3JtYXRTZWN1cml0eURpZmYoKTtcbiAgICAgICAgICAvLyBXYXJuLCBjb3VudCwgYW5kIGRpc3BsYXkgdGhlIGRpZmYgb25seSBpZiB0aGUgcmVwb3J0ZWQgY2hhbmdlcyBhcmUgYnJvYWRlbmluZyBwZXJtaXNzaW9uc1xuICAgICAgICAgIGlmIChzZWN1cml0eURpZmYucGVybWlzc2lvbkNoYW5nZVR5cGUgPT09IFBlcm1pc3Npb25DaGFuZ2VUeXBlLkJST0FERU5JTkcpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoJ1RoaXMgZGVwbG95bWVudCB3aWxsIG1ha2UgcG90ZW50aWFsbHkgc2Vuc2l0aXZlIGNoYW5nZXMgYWNjb3JkaW5nIHRvIHlvdXIgY3VycmVudCBzZWN1cml0eSBhcHByb3ZhbCBsZXZlbC5cXG5QbGVhc2UgY29uZmlybSB5b3UgaW50ZW5kIHRvIG1ha2UgdGhlIGZvbGxvd2luZyBtb2RpZmljYXRpb25zOlxcbicpO1xuICAgICAgICAgICAgaW5mbyhzZWN1cml0eURpZmYuZm9ybWF0dGVkRGlmZik7XG4gICAgICAgICAgICBkaWZmcyArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBkaWZmID0gZm9ybWF0dGVyLmZvcm1hdFN0YWNrRGlmZih7XG4gICAgICAgICAgICBzdHJpY3QsXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0TGluZXMsXG4gICAgICAgICAgICBxdWlldCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbmZvKGRpZmYuZm9ybWF0dGVkRGlmZik7XG4gICAgICAgICAgZGlmZnMgKz0gZGlmZi5udW1TdGFja3NXaXRoQ2hhbmdlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluZm8oZm9ybWF0KCdcXG7inKggIE51bWJlciBvZiBzdGFja3Mgd2l0aCBkaWZmZXJlbmNlczogJXNcXG4nLCBkaWZmcykpO1xuXG4gICAgcmV0dXJuIGRpZmZzICYmIG9wdGlvbnMuZmFpbCA/IDEgOiAwO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlcGxveShvcHRpb25zOiBEZXBsb3lPcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMud2F0Y2gpIHtcbiAgICAgIHJldHVybiB0aGlzLndhdGNoKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIHNldCBwcm9ncmVzcyBmcm9tIG9wdGlvbnMsIHRoaXMgaW5jbHVkZXMgdXNlciBhbmQgYXBwIGNvbmZpZ1xuICAgIGlmIChvcHRpb25zLnByb2dyZXNzKSB7XG4gICAgICB0aGlzLmlvSG9zdC5zdGFja1Byb2dyZXNzID0gb3B0aW9ucy5wcm9ncmVzcztcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydFN5bnRoVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGNvbnN0IHN0YWNrQ29sbGVjdGlvbiA9IGF3YWl0IHRoaXMuc2VsZWN0U3RhY2tzRm9yRGVwbG95KFxuICAgICAgb3B0aW9ucy5zZWxlY3RvcixcbiAgICAgIG9wdGlvbnMuZXhjbHVzaXZlbHksXG4gICAgICBvcHRpb25zLmNhY2hlQ2xvdWRBc3NlbWJseSxcbiAgICAgIG9wdGlvbnMuaWdub3JlTm9TdGFja3MsXG4gICAgKTtcbiAgICBjb25zdCBlbGFwc2VkU3ludGhUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFN5bnRoVGltZTtcbiAgICBpbmZvKGBcXG7inKggIFN5bnRoZXNpcyB0aW1lOiAke2Zvcm1hdFRpbWUoZWxhcHNlZFN5bnRoVGltZSl9c1xcbmApO1xuXG4gICAgaWYgKHN0YWNrQ29sbGVjdGlvbi5zdGFja0NvdW50ID09PSAwKSB7XG4gICAgICBlcnJvcignVGhpcyBhcHAgY29udGFpbnMgbm8gc3RhY2tzJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWlncmF0b3IgPSBuZXcgUmVzb3VyY2VNaWdyYXRvcih7XG4gICAgICBkZXBsb3ltZW50czogdGhpcy5wcm9wcy5kZXBsb3ltZW50cyxcbiAgICAgIGlvSGVscGVyOiBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCAnZGVwbG95JyksXG4gICAgfSk7XG4gICAgYXdhaXQgbWlncmF0b3IudHJ5TWlncmF0ZVJlc291cmNlcyhzdGFja0NvbGxlY3Rpb24sIHtcbiAgICAgIHRvb2xraXRTdGFja05hbWU6IHRoaXMudG9vbGtpdFN0YWNrTmFtZSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICBjb25zdCByZXF1aXJlQXBwcm92YWwgPSBvcHRpb25zLnJlcXVpcmVBcHByb3ZhbCA/PyBSZXF1aXJlQXBwcm92YWwuQlJPQURFTklORztcblxuICAgIGNvbnN0IHBhcmFtZXRlck1hcCA9IGJ1aWxkUGFyYW1ldGVyTWFwKG9wdGlvbnMucGFyYW1ldGVycyk7XG5cbiAgICBpZiAob3B0aW9ucy5ob3Rzd2FwICE9PSBIb3Rzd2FwTW9kZS5GVUxMX0RFUExPWU1FTlQpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgICfimqDvuI8gVGhlIC0taG90c3dhcCBhbmQgLS1ob3Rzd2FwLWZhbGxiYWNrIGZsYWdzIGRlbGliZXJhdGVseSBpbnRyb2R1Y2UgQ2xvdWRGb3JtYXRpb24gZHJpZnQgdG8gc3BlZWQgdXAgZGVwbG95bWVudHMnLFxuICAgICAgKTtcbiAgICAgIHdhcm5pbmcoJ+KaoO+4jyBUaGV5IHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGRldmVsb3BtZW50IC0gbmV2ZXIgdXNlIHRoZW0gZm9yIHlvdXIgcHJvZHVjdGlvbiBTdGFja3MhXFxuJyk7XG4gICAgfVxuXG4gICAgbGV0IGhvdHN3YXBQcm9wZXJ0aWVzRnJvbVNldHRpbmdzID0gdGhpcy5wcm9wcy5jb25maWd1cmF0aW9uLnNldHRpbmdzLmdldChbJ2hvdHN3YXAnXSkgfHwge307XG5cbiAgICBsZXQgaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzID0gbmV3IEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcygpO1xuICAgIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcy5lY3NIb3Rzd2FwUHJvcGVydGllcyA9IG5ldyBFY3NIb3Rzd2FwUHJvcGVydGllcyhcbiAgICAgIGhvdHN3YXBQcm9wZXJ0aWVzRnJvbVNldHRpbmdzLmVjcz8ubWluaW11bUhlYWx0aHlQZXJjZW50LFxuICAgICAgaG90c3dhcFByb3BlcnRpZXNGcm9tU2V0dGluZ3MuZWNzPy5tYXhpbXVtSGVhbHRoeVBlcmNlbnQsXG4gICAgKTtcblxuICAgIGNvbnN0IHN0YWNrcyA9IHN0YWNrQ29sbGVjdGlvbi5zdGFja0FydGlmYWN0cztcblxuICAgIGNvbnN0IHN0YWNrT3V0cHV0czogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuICAgIGNvbnN0IG91dHB1dHNGaWxlID0gb3B0aW9ucy5vdXRwdXRzRmlsZTtcblxuICAgIGNvbnN0IGJ1aWxkQXNzZXQgPSBhc3luYyAoYXNzZXROb2RlOiBBc3NldEJ1aWxkTm9kZSkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5wcm9wcy5kZXBsb3ltZW50cy5idWlsZFNpbmdsZUFzc2V0KFxuICAgICAgICBhc3NldE5vZGUuYXNzZXRNYW5pZmVzdEFydGlmYWN0LFxuICAgICAgICBhc3NldE5vZGUuYXNzZXRNYW5pZmVzdCxcbiAgICAgICAgYXNzZXROb2RlLmFzc2V0LFxuICAgICAgICB7XG4gICAgICAgICAgc3RhY2s6IGFzc2V0Tm9kZS5wYXJlbnRTdGFjayxcbiAgICAgICAgICByb2xlQXJuOiBvcHRpb25zLnJvbGVBcm4sXG4gICAgICAgICAgc3RhY2tOYW1lOiBhc3NldE5vZGUucGFyZW50U3RhY2suc3RhY2tOYW1lLFxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcHVibGlzaEFzc2V0ID0gYXN5bmMgKGFzc2V0Tm9kZTogQXNzZXRQdWJsaXNoTm9kZSkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5wcm9wcy5kZXBsb3ltZW50cy5wdWJsaXNoU2luZ2xlQXNzZXQoYXNzZXROb2RlLmFzc2V0TWFuaWZlc3QsIGFzc2V0Tm9kZS5hc3NldCwge1xuICAgICAgICBzdGFjazogYXNzZXROb2RlLnBhcmVudFN0YWNrLFxuICAgICAgICByb2xlQXJuOiBvcHRpb25zLnJvbGVBcm4sXG4gICAgICAgIHN0YWNrTmFtZTogYXNzZXROb2RlLnBhcmVudFN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgZm9yY2VQdWJsaXNoOiBvcHRpb25zLmZvcmNlLFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGRlcGxveVN0YWNrID0gYXN5bmMgKHN0YWNrTm9kZTogU3RhY2tOb2RlKSA9PiB7XG4gICAgICBjb25zdCBzdGFjayA9IHN0YWNrTm9kZS5zdGFjaztcbiAgICAgIGlmIChzdGFja0NvbGxlY3Rpb24uc3RhY2tDb3VudCAhPT0gMSkge1xuICAgICAgICBoaWdobGlnaHQoc3RhY2suZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN0YWNrLmVudmlyb25tZW50KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAc3R5bGlzdGljL21heC1sZW5cbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgICBgU3RhY2sgJHtzdGFjay5kaXNwbGF5TmFtZX0gZG9lcyBub3QgZGVmaW5lIGFuIGVudmlyb25tZW50LCBhbmQgQVdTIGNyZWRlbnRpYWxzIGNvdWxkIG5vdCBiZSBvYnRhaW5lZCBmcm9tIHN0YW5kYXJkIGxvY2F0aW9ucyBvciBubyByZWdpb24gd2FzIGNvbmZpZ3VyZWQuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5rZXlzKHN0YWNrLnRlbXBsYXRlLlJlc291cmNlcyB8fCB7fSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFRoZSBnZW5lcmF0ZWQgc3RhY2sgaGFzIG5vIHJlc291cmNlc1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLnByb3BzLmRlcGxveW1lbnRzLnN0YWNrRXhpc3RzKHsgc3RhY2sgfSkpKSB7XG4gICAgICAgICAgd2FybmluZygnJXM6IHN0YWNrIGhhcyBubyByZXNvdXJjZXMsIHNraXBwaW5nIGRlcGxveW1lbnQuJywgY2hhbGsuYm9sZChzdGFjay5kaXNwbGF5TmFtZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5pbmcoJyVzOiBzdGFjayBoYXMgbm8gcmVzb3VyY2VzLCBkZWxldGluZyBleGlzdGluZyBzdGFjay4nLCBjaGFsay5ib2xkKHN0YWNrLmRpc3BsYXlOYW1lKSk7XG4gICAgICAgICAgYXdhaXQgdGhpcy5kZXN0cm95KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiB7IHBhdHRlcm5zOiBbc3RhY2suaGllcmFyY2hpY2FsSWRdIH0sXG4gICAgICAgICAgICBleGNsdXNpdmVseTogdHJ1ZSxcbiAgICAgICAgICAgIGZvcmNlOiB0cnVlLFxuICAgICAgICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgICAgICAgZnJvbURlcGxveTogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXF1aXJlQXBwcm92YWwgIT09IFJlcXVpcmVBcHByb3ZhbC5ORVZFUikge1xuICAgICAgICBjb25zdCBjdXJyZW50VGVtcGxhdGUgPSBhd2FpdCB0aGlzLnByb3BzLmRlcGxveW1lbnRzLnJlYWRDdXJyZW50VGVtcGxhdGUoc3RhY2spO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgRGlmZkZvcm1hdHRlcih7XG4gICAgICAgICAgaW9IZWxwZXI6IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsICdkZXBsb3knKSxcbiAgICAgICAgICB0ZW1wbGF0ZUluZm86IHtcbiAgICAgICAgICAgIG9sZFRlbXBsYXRlOiBjdXJyZW50VGVtcGxhdGUsXG4gICAgICAgICAgICBuZXdUZW1wbGF0ZTogc3RhY2ssXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNlY3VyaXR5RGlmZiA9IGZvcm1hdHRlci5mb3JtYXRTZWN1cml0eURpZmYoKTtcbiAgICAgICAgaWYgKHJlcXVpcmVzQXBwcm92YWwocmVxdWlyZUFwcHJvdmFsLCBzZWN1cml0eURpZmYucGVybWlzc2lvbkNoYW5nZVR5cGUpKSB7XG4gICAgICAgICAgaW5mbyhzZWN1cml0eURpZmYuZm9ybWF0dGVkRGlmZik7XG4gICAgICAgICAgYXdhaXQgYXNrVXNlckNvbmZpcm1hdGlvbihcbiAgICAgICAgICAgIHRoaXMuaW9Ib3N0LFxuICAgICAgICAgICAgY29uY3VycmVuY3ksXG4gICAgICAgICAgICAnXCItLXJlcXVpcmUtYXBwcm92YWxcIiBpcyBlbmFibGVkIGFuZCBzdGFjayBpbmNsdWRlcyBzZWN1cml0eS1zZW5zaXRpdmUgdXBkYXRlcycsXG4gICAgICAgICAgICAnRG8geW91IHdpc2ggdG8gZGVwbG95IHRoZXNlIGNoYW5nZXMnLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRm9sbG93aW5nIGFyZSB0aGUgc2FtZSBzZW1hbnRpY3Mgd2UgYXBwbHkgd2l0aCByZXNwZWN0IHRvIE5vdGlmaWNhdGlvbiBBUk5zIChkaWN0YXRlZCBieSB0aGUgU0RLKVxuICAgICAgLy9cbiAgICAgIC8vICAtIHVuZGVmaW5lZCAgPT4gIGNkayBpZ25vcmVzIGl0LCBhcyBpZiBpdCB3YXNuJ3Qgc3VwcG9ydGVkIChhbGxvd3MgZXh0ZXJuYWwgbWFuYWdlbWVudCkuXG4gICAgICAvLyAgLSBbXTogICAgICAgID0+ICBjZGsgbWFuYWdlcyBpdCwgYW5kIHRoZSB1c2VyIHdhbnRzIHRvIHdpcGUgaXQgb3V0LlxuICAgICAgLy8gIC0gWydhcm4tMSddICA9PiAgY2RrIG1hbmFnZXMgaXQsIGFuZCB0aGUgdXNlciB3YW50cyB0byBzZXQgaXQgdG8gWydhcm4tMSddLlxuICAgICAgY29uc3Qgbm90aWZpY2F0aW9uQXJucyA9ICghIW9wdGlvbnMubm90aWZpY2F0aW9uQXJucyB8fCAhIXN0YWNrLm5vdGlmaWNhdGlvbkFybnMpXG4gICAgICAgID8gKG9wdGlvbnMubm90aWZpY2F0aW9uQXJucyA/PyBbXSkuY29uY2F0KHN0YWNrLm5vdGlmaWNhdGlvbkFybnMgPz8gW10pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBmb3IgKGNvbnN0IG5vdGlmaWNhdGlvbkFybiBvZiBub3RpZmljYXRpb25Bcm5zID8/IFtdKSB7XG4gICAgICAgIGlmICghdmFsaWRhdGVTbnNUb3BpY0Fybihub3RpZmljYXRpb25Bcm4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgTm90aWZpY2F0aW9uIGFybiAke25vdGlmaWNhdGlvbkFybn0gaXMgbm90IGEgdmFsaWQgYXJuIGZvciBhbiBTTlMgdG9waWNgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGFja0luZGV4ID0gc3RhY2tzLmluZGV4T2Yoc3RhY2spICsgMTtcbiAgICAgIGluZm8oYCR7Y2hhbGsuYm9sZChzdGFjay5kaXNwbGF5TmFtZSl9OiBkZXBsb3lpbmcuLi4gWyR7c3RhY2tJbmRleH0vJHtzdGFja0NvbGxlY3Rpb24uc3RhY2tDb3VudH1dYCk7XG4gICAgICBjb25zdCBzdGFydERlcGxveVRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgbGV0IHRhZ3MgPSBvcHRpb25zLnRhZ3M7XG4gICAgICBpZiAoIXRhZ3MgfHwgdGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGFncyA9IHRhZ3NGb3JTdGFjayhzdGFjayk7XG4gICAgICB9XG5cbiAgICAgIGxldCBlbGFwc2VkRGVwbG95VGltZSA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgZGVwbG95UmVzdWx0OiBTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgbGV0IHJvbGxiYWNrID0gb3B0aW9ucy5yb2xsYmFjaztcbiAgICAgICAgbGV0IGl0ZXJhdGlvbiA9IDA7XG4gICAgICAgIHdoaWxlICghZGVwbG95UmVzdWx0KSB7XG4gICAgICAgICAgaWYgKCsraXRlcmF0aW9uID4gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignVGhpcyBsb29wIHNob3VsZCBoYXZlIHN0YWJpbGl6ZWQgaW4gMiBpdGVyYXRpb25zLCBidXQgZGlkblxcJ3QuIElmIHlvdSBhcmUgc2VlaW5nIHRoaXMgZXJyb3IsIHBsZWFzZSByZXBvcnQgaXQgYXQgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy9uZXcvY2hvb3NlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMucHJvcHMuZGVwbG95bWVudHMuZGVwbG95U3RhY2soe1xuICAgICAgICAgICAgc3RhY2ssXG4gICAgICAgICAgICBkZXBsb3lOYW1lOiBzdGFjay5zdGFja05hbWUsXG4gICAgICAgICAgICByb2xlQXJuOiBvcHRpb25zLnJvbGVBcm4sXG4gICAgICAgICAgICB0b29sa2l0U3RhY2tOYW1lOiBvcHRpb25zLnRvb2xraXRTdGFja05hbWUsXG4gICAgICAgICAgICByZXVzZUFzc2V0czogb3B0aW9ucy5yZXVzZUFzc2V0cyxcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbkFybnMsXG4gICAgICAgICAgICB0YWdzLFxuICAgICAgICAgICAgZXhlY3V0ZTogb3B0aW9ucy5leGVjdXRlLFxuICAgICAgICAgICAgY2hhbmdlU2V0TmFtZTogb3B0aW9ucy5jaGFuZ2VTZXROYW1lLFxuICAgICAgICAgICAgZGVwbG95bWVudE1ldGhvZDogb3B0aW9ucy5kZXBsb3ltZW50TWV0aG9kLFxuICAgICAgICAgICAgZm9yY2VEZXBsb3ltZW50OiBvcHRpb25zLmZvcmNlLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1ldGVyTWFwWycqJ10sIHBhcmFtZXRlck1hcFtzdGFjay5zdGFja05hbWVdKSxcbiAgICAgICAgICAgIHVzZVByZXZpb3VzUGFyYW1ldGVyczogb3B0aW9ucy51c2VQcmV2aW91c1BhcmFtZXRlcnMsXG4gICAgICAgICAgICByb2xsYmFjayxcbiAgICAgICAgICAgIGhvdHN3YXA6IG9wdGlvbnMuaG90c3dhcCxcbiAgICAgICAgICAgIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlczogaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzLFxuICAgICAgICAgICAgZXh0cmFVc2VyQWdlbnQ6IG9wdGlvbnMuZXh0cmFVc2VyQWdlbnQsXG4gICAgICAgICAgICBhc3NldFBhcmFsbGVsaXNtOiBvcHRpb25zLmFzc2V0UGFyYWxsZWxpc20sXG4gICAgICAgICAgICBpZ25vcmVOb1N0YWNrczogb3B0aW9ucy5pZ25vcmVOb1N0YWNrcyxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHN3aXRjaCAoci50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkaWQtZGVwbG95LXN0YWNrJzpcbiAgICAgICAgICAgICAgZGVwbG95UmVzdWx0ID0gcjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2ZhaWxwYXVzZWQtbmVlZC1yb2xsYmFjay1maXJzdCc6IHtcbiAgICAgICAgICAgICAgY29uc3QgbW90aXZhdGlvbiA9IHIucmVhc29uID09PSAncmVwbGFjZW1lbnQnXG4gICAgICAgICAgICAgICAgPyBgU3RhY2sgaXMgaW4gYSBwYXVzZWQgZmFpbCBzdGF0ZSAoJHtyLnN0YXR1c30pIGFuZCBjaGFuZ2UgaW5jbHVkZXMgYSByZXBsYWNlbWVudCB3aGljaCBjYW5ub3QgYmUgZGVwbG95ZWQgd2l0aCBcIi0tbm8tcm9sbGJhY2tcImBcbiAgICAgICAgICAgICAgICA6IGBTdGFjayBpcyBpbiBhIHBhdXNlZCBmYWlsIHN0YXRlICgke3Iuc3RhdHVzfSkgYW5kIGNvbW1hbmQgbGluZSBhcmd1bWVudHMgZG8gbm90IGluY2x1ZGUgXCItLW5vLXJvbGxiYWNrXCJgO1xuXG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmZvcmNlKSB7XG4gICAgICAgICAgICAgICAgd2FybmluZyhgJHttb3RpdmF0aW9ufS4gUm9sbGluZyBiYWNrIGZpcnN0ICgtLWZvcmNlKS5gKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBhc2tVc2VyQ29uZmlybWF0aW9uKFxuICAgICAgICAgICAgICAgICAgdGhpcy5pb0hvc3QsXG4gICAgICAgICAgICAgICAgICBjb25jdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgIG1vdGl2YXRpb24sXG4gICAgICAgICAgICAgICAgICBgJHttb3RpdmF0aW9ufS4gUm9sbCBiYWNrIGZpcnN0IGFuZCB0aGVuIHByb2NlZWQgd2l0aCBkZXBsb3ltZW50YCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gUGVyZm9ybSBhIHJvbGxiYWNrXG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMucm9sbGJhY2soe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiB7IHBhdHRlcm5zOiBbc3RhY2suaGllcmFyY2hpY2FsSWRdIH0sXG4gICAgICAgICAgICAgICAgdG9vbGtpdFN0YWNrTmFtZTogb3B0aW9ucy50b29sa2l0U3RhY2tOYW1lLFxuICAgICAgICAgICAgICAgIGZvcmNlOiBvcHRpb25zLmZvcmNlLFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAvLyBHbyBhcm91bmQgdGhyb3VnaCB0aGUgJ3doaWxlJyBsb29wIGFnYWluIGJ1dCBzd2l0Y2ggcm9sbGJhY2sgdG8gdHJ1ZS5cbiAgICAgICAgICAgICAgcm9sbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAncmVwbGFjZW1lbnQtcmVxdWlyZXMtcm9sbGJhY2snOiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1vdGl2YXRpb24gPSAnQ2hhbmdlIGluY2x1ZGVzIGEgcmVwbGFjZW1lbnQgd2hpY2ggY2Fubm90IGJlIGRlcGxveWVkIHdpdGggXCItLW5vLXJvbGxiYWNrXCInO1xuXG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmZvcmNlKSB7XG4gICAgICAgICAgICAgICAgd2FybmluZyhgJHttb3RpdmF0aW9ufS4gUHJvY2VlZGluZyB3aXRoIHJlZ3VsYXIgZGVwbG95bWVudCAoLS1mb3JjZSkuYCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYXNrVXNlckNvbmZpcm1hdGlvbihcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW9Ib3N0LFxuICAgICAgICAgICAgICAgICAgY29uY3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICBtb3RpdmF0aW9uLFxuICAgICAgICAgICAgICAgICAgYCR7bW90aXZhdGlvbn0uIFBlcmZvcm0gYSByZWd1bGFyIGRlcGxveW1lbnRgLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBHbyBhcm91bmQgdGhyb3VnaCB0aGUgJ3doaWxlJyBsb29wIGFnYWluIGJ1dCBzd2l0Y2ggcm9sbGJhY2sgdG8gdHJ1ZS5cbiAgICAgICAgICAgICAgcm9sbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgVW5leHBlY3RlZCByZXN1bHQgdHlwZSBmcm9tIGRlcGxveVN0YWNrOiAke0pTT04uc3RyaW5naWZ5KHIpfS4gSWYgeW91IGFyZSBzZWVpbmcgdGhpcyBlcnJvciwgcGxlYXNlIHJlcG9ydCBpdCBhdCBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvaXNzdWVzL25ldy9jaG9vc2VgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZXNzYWdlID0gZGVwbG95UmVzdWx0Lm5vT3BcbiAgICAgICAgICA/ICcg4pyFICAlcyAobm8gY2hhbmdlcyknXG4gICAgICAgICAgOiAnIOKchSAgJXMnO1xuXG4gICAgICAgIHN1Y2Nlc3MoJ1xcbicgKyBtZXNzYWdlLCBzdGFjay5kaXNwbGF5TmFtZSk7XG4gICAgICAgIGVsYXBzZWREZXBsb3lUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydERlcGxveVRpbWU7XG4gICAgICAgIGluZm8oYFxcbuKcqCAgRGVwbG95bWVudCB0aW1lOiAke2Zvcm1hdFRpbWUoZWxhcHNlZERlcGxveVRpbWUpfXNcXG5gKTtcblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVwbG95UmVzdWx0Lm91dHB1dHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpbmZvKCdPdXRwdXRzOicpO1xuXG4gICAgICAgICAgc3RhY2tPdXRwdXRzW3N0YWNrLnN0YWNrTmFtZV0gPSBkZXBsb3lSZXN1bHQub3V0cHV0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhkZXBsb3lSZXN1bHQub3V0cHV0cykuc29ydCgpKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBkZXBsb3lSZXN1bHQub3V0cHV0c1tuYW1lXTtcbiAgICAgICAgICBpbmZvKGAke2NoYWxrLmN5YW4oc3RhY2suaWQpfS4ke2NoYWxrLmN5YW4obmFtZSl9ID0gJHtjaGFsay51bmRlcmxpbmUoY2hhbGsuY3lhbih2YWx1ZSkpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5mbygnU3RhY2sgQVJOOicpO1xuXG4gICAgICAgIGxvZ1Jlc3VsdChkZXBsb3lSZXN1bHQuc3RhY2tBcm4pO1xuICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgIC8vIEl0IGhhcyB0byBiZSBleGFjdGx5IHRoaXMgc3RyaW5nIGJlY2F1c2UgYW4gaW50ZWdyYXRpb24gdGVzdCB0ZXN0cyBmb3JcbiAgICAgICAgLy8gXCJib2xkKHN0YWNrbmFtZSkgZmFpbGVkOiBSZXNvdXJjZU5vdFJlYWR5OiA8ZXJyb3I+XCJcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgICBbYOKdjCAgJHtjaGFsay5ib2xkKHN0YWNrLnN0YWNrTmFtZSl9IGZhaWxlZDpgLCAuLi4oZS5uYW1lID8gW2Ake2UubmFtZX06YF0gOiBbXSksIGZvcm1hdEVycm9yTWVzc2FnZShlKV0uam9pbignICcpLFxuICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2xvdWRXYXRjaExvZ01vbml0b3IpIHtcbiAgICAgICAgICBjb25zdCBmb3VuZExvZ0dyb3Vwc1Jlc3VsdCA9IGF3YWl0IGZpbmRDbG91ZFdhdGNoTG9nR3JvdXBzKHRoaXMucHJvcHMuc2RrUHJvdmlkZXIsIGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsICdkZXBsb3knKSwgc3RhY2spO1xuICAgICAgICAgIG9wdGlvbnMuY2xvdWRXYXRjaExvZ01vbml0b3IuYWRkTG9nR3JvdXBzKFxuICAgICAgICAgICAgZm91bmRMb2dHcm91cHNSZXN1bHQuZW52LFxuICAgICAgICAgICAgZm91bmRMb2dHcm91cHNSZXN1bHQuc2RrLFxuICAgICAgICAgICAgZm91bmRMb2dHcm91cHNSZXN1bHQubG9nR3JvdXBOYW1lcyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGFuIG91dHB1dHMgZmlsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIGNyZWF0ZSB0aGUgZmlsZSBwYXRoIGFuZCB3cml0ZSBzdGFjayBvdXRwdXRzIHRvIGl0IG9uY2UuXG4gICAgICAgIC8vIE91dHB1dHMgYXJlIHdyaXR0ZW4gYWZ0ZXIgYWxsIHN0YWNrcyBoYXZlIGJlZW4gZGVwbG95ZWQuIElmIGEgc3RhY2sgZGVwbG95bWVudCBmYWlscyxcbiAgICAgICAgLy8gYWxsIG9mIHRoZSBvdXRwdXRzIGZyb20gc3VjY2Vzc2Z1bGx5IGRlcGxveWVkIHN0YWNrcyBiZWZvcmUgdGhlIGZhaWx1cmUgd2lsbCBzdGlsbCBiZSB3cml0dGVuLlxuICAgICAgICBpZiAob3V0cHV0c0ZpbGUpIHtcbiAgICAgICAgICBmcy5lbnN1cmVGaWxlU3luYyhvdXRwdXRzRmlsZSk7XG4gICAgICAgICAgYXdhaXQgZnMud3JpdGVKc29uKG91dHB1dHNGaWxlLCBzdGFja091dHB1dHMsIHtcbiAgICAgICAgICAgIHNwYWNlczogMixcbiAgICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluZm8oYFxcbuKcqCAgVG90YWwgdGltZTogJHtmb3JtYXRUaW1lKGVsYXBzZWRTeW50aFRpbWUgKyBlbGFwc2VkRGVwbG95VGltZSl9c1xcbmApO1xuICAgIH07XG5cbiAgICBjb25zdCBhc3NldEJ1aWxkVGltZSA9IG9wdGlvbnMuYXNzZXRCdWlsZFRpbWUgPz8gQXNzZXRCdWlsZFRpbWUuQUxMX0JFRk9SRV9ERVBMT1k7XG4gICAgY29uc3QgcHJlYnVpbGRBc3NldHMgPSBhc3NldEJ1aWxkVGltZSA9PT0gQXNzZXRCdWlsZFRpbWUuQUxMX0JFRk9SRV9ERVBMT1k7XG4gICAgY29uc3QgY29uY3VycmVuY3kgPSBvcHRpb25zLmNvbmN1cnJlbmN5IHx8IDE7XG4gICAgaWYgKGNvbmN1cnJlbmN5ID4gMSkge1xuICAgICAgLy8gYWx3YXlzIGZvcmNlIFwiZXZlbnRzXCIgcHJvZ3Jlc3Mgb3V0cHV0IHdoZW4gd2UgaGF2ZSBjb25jdXJyZW5jeVxuICAgICAgdGhpcy5pb0hvc3Quc3RhY2tQcm9ncmVzcyA9IFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5FVkVOVFM7XG5cbiAgICAgIC8vIC4uLmJ1dCBvbmx5IHdhcm4gaWYgdGhlIHVzZXIgZXhwbGljaXRseSByZXF1ZXN0ZWQgXCJiYXJcIiBwcm9ncmVzc1xuICAgICAgaWYgKG9wdGlvbnMucHJvZ3Jlc3MgJiYgb3B0aW9ucy5wcm9ncmVzcyAhPSBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MuRVZFTlRTKSB7XG4gICAgICAgIHdhcm5pbmcoJ+KaoO+4jyBUaGUgLS1jb25jdXJyZW5jeSBmbGFnIG9ubHkgc3VwcG9ydHMgLS1wcm9ncmVzcyBcImV2ZW50c1wiLiBTd2l0Y2hpbmcgdG8gXCJldmVudHNcIi4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdGFja3NBbmRUaGVpckFzc2V0TWFuaWZlc3RzID0gc3RhY2tzLmZsYXRNYXAoKHN0YWNrKSA9PiBbXG4gICAgICBzdGFjayxcbiAgICAgIC4uLnN0YWNrLmRlcGVuZGVuY2llcy5maWx0ZXIoeCA9PiBjeGFwaS5Bc3NldE1hbmlmZXN0QXJ0aWZhY3QuaXNBc3NldE1hbmlmZXN0QXJ0aWZhY3QoeCkpLFxuICAgIF0pO1xuICAgIGNvbnN0IHdvcmtHcmFwaCA9IG5ldyBXb3JrR3JhcGhCdWlsZGVyKFxuICAgICAgYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ2RlcGxveScpLFxuICAgICAgcHJlYnVpbGRBc3NldHMsXG4gICAgKS5idWlsZChzdGFja3NBbmRUaGVpckFzc2V0TWFuaWZlc3RzKTtcblxuICAgIC8vIFVubGVzcyB3ZSBhcmUgcnVubmluZyB3aXRoICctLWZvcmNlJywgc2tpcCBhbHJlYWR5IHB1Ymxpc2hlZCBhc3NldHNcbiAgICBpZiAoIW9wdGlvbnMuZm9yY2UpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVtb3ZlUHVibGlzaGVkQXNzZXRzKHdvcmtHcmFwaCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3QgZ3JhcGhDb25jdXJyZW5jeTogQ29uY3VycmVuY3kgPSB7XG4gICAgICAnc3RhY2snOiBjb25jdXJyZW5jeSxcbiAgICAgICdhc3NldC1idWlsZCc6IDEsIC8vIFRoaXMgd2lsbCBiZSBDUFUtYm91bmQvbWVtb3J5IGJvdW5kLCBtb3N0bHkgbWF0dGVycyBmb3IgRG9ja2VyIGJ1aWxkc1xuICAgICAgJ2Fzc2V0LXB1Ymxpc2gnOiAob3B0aW9ucy5hc3NldFBhcmFsbGVsaXNtID8/IHRydWUpID8gOCA6IDEsIC8vIFRoaXMgd2lsbCBiZSBJL08tYm91bmQsIDggaW4gcGFyYWxsZWwgc2VlbXMgcmVhc29uYWJsZVxuICAgIH07XG5cbiAgICBhd2FpdCB3b3JrR3JhcGguZG9QYXJhbGxlbChncmFwaENvbmN1cnJlbmN5LCB7XG4gICAgICBkZXBsb3lTdGFjayxcbiAgICAgIGJ1aWxkQXNzZXQsXG4gICAgICBwdWJsaXNoQXNzZXQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUm9sbCBiYWNrIHRoZSBnaXZlbiBzdGFjayBvciBzdGFja3MuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcm9sbGJhY2sob3B0aW9uczogUm9sbGJhY2tPcHRpb25zKSB7XG4gICAgY29uc3Qgc3RhcnRTeW50aFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCBzdGFja0NvbGxlY3Rpb24gPSBhd2FpdCB0aGlzLnNlbGVjdFN0YWNrc0ZvckRlcGxveShvcHRpb25zLnNlbGVjdG9yLCB0cnVlKTtcbiAgICBjb25zdCBlbGFwc2VkU3ludGhUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFN5bnRoVGltZTtcbiAgICBpbmZvKGBcXG7inKggIFN5bnRoZXNpcyB0aW1lOiAke2Zvcm1hdFRpbWUoZWxhcHNlZFN5bnRoVGltZSl9c1xcbmApO1xuXG4gICAgaWYgKHN0YWNrQ29sbGVjdGlvbi5zdGFja0NvdW50ID09PSAwKSB7XG4gICAgICBlcnJvcignTm8gc3RhY2tzIHNlbGVjdGVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGFueVJvbGxiYWNrYWJsZSA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja0NvbGxlY3Rpb24uc3RhY2tBcnRpZmFjdHMpIHtcbiAgICAgIGluZm8oJ1JvbGxpbmcgYmFjayAlcycsIGNoYWxrLmJvbGQoc3RhY2suZGlzcGxheU5hbWUpKTtcbiAgICAgIGNvbnN0IHN0YXJ0Um9sbGJhY2tUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnByb3BzLmRlcGxveW1lbnRzLnJvbGxiYWNrU3RhY2soe1xuICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgIHJvbGVBcm46IG9wdGlvbnMucm9sZUFybixcbiAgICAgICAgICB0b29sa2l0U3RhY2tOYW1lOiBvcHRpb25zLnRvb2xraXRTdGFja05hbWUsXG4gICAgICAgICAgb3JwaGFuRmFpbGVkUmVzb3VyY2VzOiBvcHRpb25zLmZvcmNlLFxuICAgICAgICAgIHZhbGlkYXRlQm9vdHN0cmFwU3RhY2tWZXJzaW9uOiBvcHRpb25zLnZhbGlkYXRlQm9vdHN0cmFwU3RhY2tWZXJzaW9uLFxuICAgICAgICAgIG9ycGhhbkxvZ2ljYWxJZHM6IG9wdGlvbnMub3JwaGFuTG9naWNhbElkcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzdWx0Lm5vdEluUm9sbGJhY2thYmxlU3RhdGUpIHtcbiAgICAgICAgICBhbnlSb2xsYmFja2FibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsYXBzZWRSb2xsYmFja1RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0Um9sbGJhY2tUaW1lO1xuICAgICAgICBpbmZvKGBcXG7inKggIFJvbGxiYWNrIHRpbWU6ICR7Zm9ybWF0VGltZShlbGFwc2VkUm9sbGJhY2tUaW1lKS50b1N0cmluZygpfXNcXG5gKTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICBlcnJvcignXFxuIOKdjCAgJXMgZmFpbGVkOiAlcycsIGNoYWxrLmJvbGQoc3RhY2suZGlzcGxheU5hbWUpLCBmb3JtYXRFcnJvck1lc3NhZ2UoZSkpO1xuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCdSb2xsYmFjayBmYWlsZWQgKHVzZSAtLWZvcmNlIHRvIG9ycGhhbiBmYWlsaW5nIHJlc291cmNlcyknKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFhbnlSb2xsYmFja2FibGUpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ05vIHN0YWNrcyB3ZXJlIGluIGEgc3RhdGUgdGhhdCBjb3VsZCBiZSByb2xsZWQgYmFjaycpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB3YXRjaChvcHRpb25zOiBXYXRjaE9wdGlvbnMpIHtcbiAgICBjb25zdCByb290RGlyID0gcGF0aC5kaXJuYW1lKHBhdGgucmVzb2x2ZShQUk9KRUNUX0NPTkZJRykpO1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ3dhdGNoJyk7XG4gICAgZGVidWcoXCJyb290IGRpcmVjdG9yeSB1c2VkIGZvciAnd2F0Y2gnIGlzOiAlc1wiLCByb290RGlyKTtcblxuICAgIGNvbnN0IHdhdGNoU2V0dGluZ3M6IHsgaW5jbHVkZT86IHN0cmluZyB8IHN0cmluZ1tdOyBleGNsdWRlOiBzdHJpbmcgfCBzdHJpbmdbXSB9IHwgdW5kZWZpbmVkID1cbiAgICAgIHRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWyd3YXRjaCddKTtcbiAgICBpZiAoIXdhdGNoU2V0dGluZ3MpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IHVzZSB0aGUgJ3dhdGNoJyBjb21tYW5kIHdpdGhvdXQgc3BlY2lmeWluZyBhdCBsZWFzdCBvbmUgZGlyZWN0b3J5IHRvIG1vbml0b3IuIFwiICtcbiAgICAgICAgICAnTWFrZSBzdXJlIHRvIGFkZCBhIFwid2F0Y2hcIiBrZXkgdG8geW91ciBjZGsuanNvbicsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEZvciB0aGUgXCJpbmNsdWRlXCIgc3Via2V5IHVuZGVyIHRoZSBcIndhdGNoXCIga2V5LCB0aGUgYmVoYXZpb3IgaXM6XG4gICAgLy8gMS4gTm8gXCJ3YXRjaFwiIHNldHRpbmc/IFdlIGVycm9yIG91dC5cbiAgICAvLyAyLiBcIndhdGNoXCIgc2V0dGluZyB3aXRob3V0IGFuIFwiaW5jbHVkZVwiIGtleT8gV2UgZGVmYXVsdCB0byBvYnNlcnZpbmcgXCIuLyoqXCIuXG4gICAgLy8gMy4gXCJ3YXRjaFwiIHNldHRpbmcgd2l0aCBhbiBlbXB0eSBcImluY2x1ZGVcIiBrZXk/IFdlIGRlZmF1bHQgdG8gb2JzZXJ2aW5nIFwiLi8qKlwiLlxuICAgIC8vIDQuIE5vbi1lbXB0eSBcImluY2x1ZGVcIiBrZXk/IEp1c3QgdXNlIHRoZSBcImluY2x1ZGVcIiBrZXkuXG4gICAgY29uc3Qgd2F0Y2hJbmNsdWRlcyA9IHRoaXMucGF0dGVybnNBcnJheUZvcldhdGNoKHdhdGNoU2V0dGluZ3MuaW5jbHVkZSwge1xuICAgICAgcm9vdERpcixcbiAgICAgIHJldHVyblJvb3REaXJJZkVtcHR5OiB0cnVlLFxuICAgIH0pO1xuICAgIGRlYnVnKFwiJ2luY2x1ZGUnIHBhdHRlcm5zIGZvciAnd2F0Y2gnOiAlc1wiLCB3YXRjaEluY2x1ZGVzKTtcblxuICAgIC8vIEZvciB0aGUgXCJleGNsdWRlXCIgc3Via2V5IHVuZGVyIHRoZSBcIndhdGNoXCIga2V5LFxuICAgIC8vIHRoZSBiZWhhdmlvciBpcyB0byBhZGQgc29tZSBkZWZhdWx0IGV4Y2x1ZGVzIGluIGFkZGl0aW9uIHRvIHRoZSBvbmVzIHNwZWNpZmllZCBieSB0aGUgdXNlcjpcbiAgICAvLyAxLiBUaGUgQ0RLIG91dHB1dCBkaXJlY3RvcnkuXG4gICAgLy8gMi4gQW55IGZpbGUgd2hvc2UgbmFtZSBzdGFydHMgd2l0aCBhIGRvdC5cbiAgICAvLyAzLiBBbnkgZGlyZWN0b3J5J3MgY29udGVudCB3aG9zZSBuYW1lIHN0YXJ0cyB3aXRoIGEgZG90LlxuICAgIC8vIDQuIEFueSBub2RlX21vZHVsZXMgYW5kIGl0cyBjb250ZW50IChldmVuIGlmIGl0J3Mgbm90IGEgSlMvVFMgcHJvamVjdCwgeW91IG1pZ2h0IGJlIHVzaW5nIGEgbG9jYWwgYXdzLWNsaSBwYWNrYWdlKVxuICAgIGNvbnN0IG91dHB1dERpciA9IHRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWydvdXRwdXQnXSk7XG4gICAgY29uc3Qgd2F0Y2hFeGNsdWRlcyA9IHRoaXMucGF0dGVybnNBcnJheUZvcldhdGNoKHdhdGNoU2V0dGluZ3MuZXhjbHVkZSwge1xuICAgICAgcm9vdERpcixcbiAgICAgIHJldHVyblJvb3REaXJJZkVtcHR5OiBmYWxzZSxcbiAgICB9KS5jb25jYXQoYCR7b3V0cHV0RGlyfS8qKmAsICcqKi8uKicsICcqKi8uKi8qKicsICcqKi9ub2RlX21vZHVsZXMvKionKTtcbiAgICBkZWJ1ZyhcIidleGNsdWRlJyBwYXR0ZXJucyBmb3IgJ3dhdGNoJzogJXNcIiwgd2F0Y2hFeGNsdWRlcyk7XG5cbiAgICAvLyBTaW5jZSAnY2RrIGRlcGxveScgaXMgYSByZWxhdGl2ZWx5IHNsb3cgb3BlcmF0aW9uIGZvciBhICd3YXRjaCcgcHJvY2VzcyxcbiAgICAvLyBpbnRyb2R1Y2UgYSBjb25jdXJyZW5jeSBsYXRjaCB0aGF0IHRyYWNrcyB0aGUgc3RhdGUuXG4gICAgLy8gVGhpcyB3YXksIGlmIGZpbGUgY2hhbmdlIGV2ZW50cyBhcnJpdmUgd2hlbiBhICdjZGsgZGVwbG95JyBpcyBzdGlsbCBleGVjdXRpbmcsXG4gICAgLy8gd2Ugd2lsbCBiYXRjaCB0aGVtLCBhbmQgdHJpZ2dlciBhbm90aGVyICdjZGsgZGVwbG95JyBhZnRlciB0aGUgY3VycmVudCBvbmUgZmluaXNoZXMsXG4gICAgLy8gbWFraW5nIHN1cmUgJ2NkayBkZXBsb3kncyAgYWx3YXlzIGV4ZWN1dGUgb25lIGF0IGEgdGltZS5cbiAgICAvLyBIZXJlJ3MgYSBkaWFncmFtIHNob3dpbmcgdGhlIHN0YXRlIHRyYW5zaXRpb25zOlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tICAgICAgICAgICAgICAgIC0tLS0tLS0tICAgIGZpbGUgY2hhbmdlZCAgICAgLS0tLS0tLS0tLS0tLS0gICAgZmlsZSBjaGFuZ2VkICAgICAtLS0tLS0tLS0tLS0tLSAgZmlsZSBjaGFuZ2VkXG4gICAgLy8gfCAgICAgICAgICAgIHwgIHJlYWR5IGV2ZW50ICAgfCAgICAgIHwgLS0tLS0tLS0tLS0tLS0tLS0tPiB8ICAgICAgICAgICAgfCAtLS0tLS0tLS0tLS0tLS0tLS0+IHwgICAgICAgICAgICB8IC0tLS0tLS0tLS0tLS0tfFxuICAgIC8vIHwgcHJlLXJlYWR5ICB8IC0tLS0tLS0tLS0tLS0+IHwgb3BlbiB8ICAgICAgICAgICAgICAgICAgICAgfCBkZXBsb3lpbmcgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgcXVldWVkICAgfCAgICAgICAgICAgICAgIHxcbiAgICAvLyB8ICAgICAgICAgICAgfCAgICAgICAgICAgICAgICB8ICAgICAgfCA8LS0tLS0tLS0tLS0tLS0tLS0tIHwgICAgICAgICAgICB8IDwtLS0tLS0tLS0tLS0tLS0tLS0gfCAgICAgICAgICAgIHwgPC0tLS0tLS0tLS0tLS18XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0gICAgICAgICAgICAgICAgLS0tLS0tLS0gICdjZGsgZGVwbG95JyBkb25lICAtLS0tLS0tLS0tLS0tLSAgJ2NkayBkZXBsb3knIGRvbmUgIC0tLS0tLS0tLS0tLS0tXG4gICAgbGV0IGxhdGNoOiAncHJlLXJlYWR5JyB8ICdvcGVuJyB8ICdkZXBsb3lpbmcnIHwgJ3F1ZXVlZCcgPSAncHJlLXJlYWR5JztcblxuICAgIGNvbnN0IGNsb3VkV2F0Y2hMb2dNb25pdG9yID0gb3B0aW9ucy50cmFjZUxvZ3MgPyBuZXcgQ2xvdWRXYXRjaExvZ0V2ZW50TW9uaXRvcih7XG4gICAgICBpb0hlbHBlcixcbiAgICB9KSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBkZXBsb3lBbmRXYXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGxhdGNoID0gJ2RlcGxveWluZyc7XG4gICAgICBhd2FpdCBjbG91ZFdhdGNoTG9nTW9uaXRvcj8uZGVhY3RpdmF0ZSgpO1xuXG4gICAgICBhd2FpdCB0aGlzLmludm9rZURlcGxveUZyb21XYXRjaChvcHRpb25zLCBjbG91ZFdhdGNoTG9nTW9uaXRvcik7XG5cbiAgICAgIC8vIElmIGxhdGNoIGlzIHN0aWxsICdkZXBsb3lpbmcnIGFmdGVyIHRoZSAnYXdhaXQnLCB0aGF0J3MgZmluZSxcbiAgICAgIC8vIGJ1dCBpZiBpdCdzICdxdWV1ZWQnLCB0aGF0IG1lYW5zIHdlIG5lZWQgdG8gZGVwbG95IGFnYWluXG4gICAgICB3aGlsZSAoKGxhdGNoIGFzICdkZXBsb3lpbmcnIHwgJ3F1ZXVlZCcpID09PSAncXVldWVkJykge1xuICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3QgcmVhbGl6ZSBsYXRjaCBjYW4gY2hhbmdlIGJldHdlZW4gJ2F3YWl0cycsXG4gICAgICAgIC8vIGFuZCB0aGlua3MgdGhlIGFib3ZlICd3aGlsZScgY29uZGl0aW9uIGlzIGFsd2F5cyAnZmFsc2UnIHdpdGhvdXQgdGhlIGNhc3RcbiAgICAgICAgbGF0Y2ggPSAnZGVwbG95aW5nJztcbiAgICAgICAgaW5mbyhcIkRldGVjdGVkIGZpbGUgY2hhbmdlcyBkdXJpbmcgZGVwbG95bWVudC4gSW52b2tpbmcgJ2NkayBkZXBsb3knIGFnYWluXCIpO1xuICAgICAgICBhd2FpdCB0aGlzLmludm9rZURlcGxveUZyb21XYXRjaChvcHRpb25zLCBjbG91ZFdhdGNoTG9nTW9uaXRvcik7XG4gICAgICB9XG4gICAgICBsYXRjaCA9ICdvcGVuJztcbiAgICAgIGF3YWl0IGNsb3VkV2F0Y2hMb2dNb25pdG9yPy5hY3RpdmF0ZSgpO1xuICAgIH07XG5cbiAgICBjaG9raWRhclxuICAgICAgLndhdGNoKHdhdGNoSW5jbHVkZXMsIHtcbiAgICAgICAgaWdub3JlZDogd2F0Y2hFeGNsdWRlcyxcbiAgICAgICAgY3dkOiByb290RGlyLFxuICAgICAgfSlcbiAgICAgIC5vbigncmVhZHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGxhdGNoID0gJ29wZW4nO1xuICAgICAgICBkZWJ1ZyhcIid3YXRjaCcgcmVjZWl2ZWQgdGhlICdyZWFkeScgZXZlbnQuIEZyb20gbm93IG9uLCBhbGwgZmlsZSBjaGFuZ2VzIHdpbGwgdHJpZ2dlciBhIGRlcGxveW1lbnRcIik7XG4gICAgICAgIGluZm8oXCJUcmlnZ2VyaW5nIGluaXRpYWwgJ2NkayBkZXBsb3knXCIpO1xuICAgICAgICBhd2FpdCBkZXBsb3lBbmRXYXRjaCgpO1xuICAgICAgfSlcbiAgICAgIC5vbignYWxsJywgYXN5bmMgKGV2ZW50OiAnYWRkJyB8ICdhZGREaXInIHwgJ2NoYW5nZScgfCAndW5saW5rJyB8ICd1bmxpbmtEaXInLCBmaWxlUGF0aD86IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAobGF0Y2ggPT09ICdwcmUtcmVhZHknKSB7XG4gICAgICAgICAgaW5mbyhgJ3dhdGNoJyBpcyBvYnNlcnZpbmcgJHtldmVudCA9PT0gJ2FkZERpcicgPyAnZGlyZWN0b3J5JyA6ICd0aGUgZmlsZSd9ICclcycgZm9yIGNoYW5nZXNgLCBmaWxlUGF0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGF0Y2ggPT09ICdvcGVuJykge1xuICAgICAgICAgIGluZm8oXCJEZXRlY3RlZCBjaGFuZ2UgdG8gJyVzJyAodHlwZTogJXMpLiBUcmlnZ2VyaW5nICdjZGsgZGVwbG95J1wiLCBmaWxlUGF0aCwgZXZlbnQpO1xuICAgICAgICAgIGF3YWl0IGRlcGxveUFuZFdhdGNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhpcyBtZWFucyBsYXRjaCBpcyBlaXRoZXIgJ2RlcGxveWluZycgb3IgJ3F1ZXVlZCdcbiAgICAgICAgICBsYXRjaCA9ICdxdWV1ZWQnO1xuICAgICAgICAgIGluZm8oXG4gICAgICAgICAgICBcIkRldGVjdGVkIGNoYW5nZSB0byAnJXMnICh0eXBlOiAlcykgd2hpbGUgJ2NkayBkZXBsb3knIGlzIHN0aWxsIHJ1bm5pbmcuIFwiICtcbiAgICAgICAgICAgICAgJ1dpbGwgcXVldWUgZm9yIGFub3RoZXIgZGVwbG95bWVudCBhZnRlciB0aGlzIG9uZSBmaW5pc2hlcycsXG4gICAgICAgICAgICBmaWxlUGF0aCxcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGltcG9ydChvcHRpb25zOiBJbXBvcnRPcHRpb25zKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgdGhpcy5zZWxlY3RTdGFja3NGb3JEZXBsb3kob3B0aW9ucy5zZWxlY3RvciwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuXG4gICAgLy8gc2V0IHByb2dyZXNzIGZyb20gb3B0aW9ucywgdGhpcyBpbmNsdWRlcyB1c2VyIGFuZCBhcHAgY29uZmlnXG4gICAgaWYgKG9wdGlvbnMucHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMuaW9Ib3N0LnN0YWNrUHJvZ3Jlc3MgPSBvcHRpb25zLnByb2dyZXNzO1xuICAgIH1cblxuICAgIGlmIChzdGFja3Muc3RhY2tDb3VudCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoXG4gICAgICAgIGBTdGFjayBzZWxlY3Rpb24gaXMgYW1iaWd1b3VzLCBwbGVhc2UgY2hvb3NlIGEgc3BlY2lmaWMgc3RhY2sgZm9yIGltcG9ydCBbJHtzdGFja3Muc3RhY2tBcnRpZmFjdHMubWFwKCh4KSA9PiB4LmlkKS5qb2luKCcsICcpfV1gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXByb2Nlc3Muc3Rkb3V0LmlzVFRZICYmICFvcHRpb25zLnJlc291cmNlTWFwcGluZ0ZpbGUpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJy0tcmVzb3VyY2UtbWFwcGluZyBpcyByZXF1aXJlZCB3aGVuIGlucHV0IGlzIG5vdCBhIHRlcm1pbmFsJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3Muc3RhY2tBcnRpZmFjdHNbMF07XG5cbiAgICBoaWdobGlnaHQoc3RhY2suZGlzcGxheU5hbWUpO1xuXG4gICAgY29uc3QgcmVzb3VyY2VJbXBvcnRlciA9IG5ldyBSZXNvdXJjZUltcG9ydGVyKHN0YWNrLCB7XG4gICAgICBkZXBsb3ltZW50czogdGhpcy5wcm9wcy5kZXBsb3ltZW50cyxcbiAgICAgIGlvSGVscGVyOiBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCAnaW1wb3J0JyksXG4gICAgfSk7XG4gICAgY29uc3QgeyBhZGRpdGlvbnMsIGhhc05vbkFkZGl0aW9ucyB9ID0gYXdhaXQgcmVzb3VyY2VJbXBvcnRlci5kaXNjb3ZlckltcG9ydGFibGVSZXNvdXJjZXMob3B0aW9ucy5mb3JjZSk7XG4gICAgaWYgKGFkZGl0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgICclczogbm8gbmV3IHJlc291cmNlcyBjb21wYXJlZCB0byB0aGUgY3VycmVudGx5IGRlcGxveWVkIHN0YWNrLCBza2lwcGluZyBpbXBvcnQuJyxcbiAgICAgICAgY2hhbGsuYm9sZChzdGFjay5kaXNwbGF5TmFtZSksXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByZXBhcmUgYSBtYXBwaW5nIG9mIHBoeXNpY2FsIHJlc291cmNlcyB0byBDREsgY29uc3RydWN0c1xuICAgIGNvbnN0IGFjdHVhbEltcG9ydCA9ICFvcHRpb25zLnJlc291cmNlTWFwcGluZ0ZpbGVcbiAgICAgID8gYXdhaXQgcmVzb3VyY2VJbXBvcnRlci5hc2tGb3JSZXNvdXJjZUlkZW50aWZpZXJzKGFkZGl0aW9ucylcbiAgICAgIDogYXdhaXQgcmVzb3VyY2VJbXBvcnRlci5sb2FkUmVzb3VyY2VJZGVudGlmaWVycyhhZGRpdGlvbnMsIG9wdGlvbnMucmVzb3VyY2VNYXBwaW5nRmlsZSk7XG5cbiAgICBpZiAoYWN0dWFsSW1wb3J0LmltcG9ydFJlc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHdhcm5pbmcoJ05vIHJlc291cmNlcyBzZWxlY3RlZCBmb3IgaW1wb3J0LicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIFwiLS1jcmVhdGUtcmVzb3VyY2UtbWFwcGluZ1wiIG9wdGlvbiB3YXMgcGFzc2VkLCB3cml0ZSB0aGUgcmVzb3VyY2UgbWFwcGluZyB0byB0aGUgZ2l2ZW4gZmlsZSBhbmQgZXhpdFxuICAgIGlmIChvcHRpb25zLnJlY29yZFJlc291cmNlTWFwcGluZykge1xuICAgICAgY29uc3Qgb3V0cHV0RmlsZSA9IG9wdGlvbnMucmVjb3JkUmVzb3VyY2VNYXBwaW5nO1xuICAgICAgZnMuZW5zdXJlRmlsZVN5bmMob3V0cHV0RmlsZSk7XG4gICAgICBhd2FpdCBmcy53cml0ZUpzb24ob3V0cHV0RmlsZSwgYWN0dWFsSW1wb3J0LnJlc291cmNlTWFwLCB7XG4gICAgICAgIHNwYWNlczogMixcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgIH0pO1xuICAgICAgaW5mbygnJXM6IG1hcHBpbmcgZmlsZSB3cml0dGVuLicsIG91dHB1dEZpbGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEltcG9ydCB0aGUgcmVzb3VyY2VzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gbWFwcGluZ1xuICAgIGluZm8oJyVzOiBpbXBvcnRpbmcgcmVzb3VyY2VzIGludG8gc3RhY2suLi4nLCBjaGFsay5ib2xkKHN0YWNrLmRpc3BsYXlOYW1lKSk7XG4gICAgY29uc3QgdGFncyA9IHRhZ3NGb3JTdGFjayhzdGFjayk7XG4gICAgYXdhaXQgcmVzb3VyY2VJbXBvcnRlci5pbXBvcnRSZXNvdXJjZXNGcm9tTWFwKGFjdHVhbEltcG9ydCwge1xuICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgdGFncyxcbiAgICAgIGRlcGxveW1lbnRNZXRob2Q6IG9wdGlvbnMuZGVwbG95bWVudE1ldGhvZCxcbiAgICAgIHVzZVByZXZpb3VzUGFyYW1ldGVyczogdHJ1ZSxcbiAgICAgIHJvbGxiYWNrOiBvcHRpb25zLnJvbGxiYWNrLFxuICAgIH0pO1xuXG4gICAgLy8gTm90aWZ5IHVzZXIgb2YgbmV4dCBzdGVwc1xuICAgIGluZm8oXG4gICAgICBgSW1wb3J0IG9wZXJhdGlvbiBjb21wbGV0ZS4gV2UgcmVjb21tZW5kIHlvdSBydW4gYSAke2NoYWxrLmJsdWVCcmlnaHQoJ2RyaWZ0IGRldGVjdGlvbicpfSBvcGVyYXRpb24gYCArXG4gICAgICAgICd0byBjb25maXJtIHlvdXIgQ0RLIGFwcCByZXNvdXJjZSBkZWZpbml0aW9ucyBhcmUgdXAtdG8tZGF0ZS4gUmVhZCBtb3JlIGhlcmU6ICcgK1xuICAgICAgICBjaGFsay51bmRlcmxpbmUuYmx1ZUJyaWdodChcbiAgICAgICAgICAnaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0Nsb3VkRm9ybWF0aW9uL2xhdGVzdC9Vc2VyR3VpZGUvZGV0ZWN0LWRyaWZ0LXN0YWNrLmh0bWwnLFxuICAgICAgICApLFxuICAgICk7XG4gICAgaWYgKGFjdHVhbEltcG9ydC5pbXBvcnRSZXNvdXJjZXMubGVuZ3RoIDwgYWRkaXRpb25zLmxlbmd0aCkge1xuICAgICAgaW5mbygnJyk7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBgU29tZSByZXNvdXJjZXMgd2VyZSBza2lwcGVkLiBSdW4gYW5vdGhlciAke2NoYWxrLmJsdWVCcmlnaHQoJ2NkayBpbXBvcnQnKX0gb3IgYSAke2NoYWxrLmJsdWVCcmlnaHQoJ2NkayBkZXBsb3knKX0gdG8gYnJpbmcgdGhlIHN0YWNrIHVwLXRvLWRhdGUgd2l0aCB5b3VyIENESyBhcHAgZGVmaW5pdGlvbi5gLFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGhhc05vbkFkZGl0aW9ucykge1xuICAgICAgaW5mbygnJyk7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBgWW91ciBhcHAgaGFzIHBlbmRpbmcgdXBkYXRlcyBvciBkZWxldGVzIGV4Y2x1ZGVkIGZyb20gdGhpcyBpbXBvcnQgb3BlcmF0aW9uLiBSdW4gYSAke2NoYWxrLmJsdWVCcmlnaHQoJ2NkayBkZXBsb3knKX0gdG8gYnJpbmcgdGhlIHN0YWNrIHVwLXRvLWRhdGUgd2l0aCB5b3VyIENESyBhcHAgZGVmaW5pdGlvbi5gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVzdHJveShvcHRpb25zOiBEZXN0cm95T3B0aW9ucykge1xuICAgIGxldCBzdGFja3MgPSBhd2FpdCB0aGlzLnNlbGVjdFN0YWNrc0ZvckRlc3Ryb3kob3B0aW9ucy5zZWxlY3Rvciwgb3B0aW9ucy5leGNsdXNpdmVseSk7XG5cbiAgICAvLyBUaGUgc3RhY2tzIHdpbGwgaGF2ZSBiZWVuIG9yZGVyZWQgZm9yIGRlcGxveW1lbnQsIHNvIHJldmVyc2UgdGhlbSBmb3IgZGVsZXRpb24uXG4gICAgc3RhY2tzID0gc3RhY2tzLnJldmVyc2VkKCk7XG5cbiAgICBpZiAoIW9wdGlvbnMuZm9yY2UpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAc3R5bGlzdGljL21heC1sZW5cbiAgICAgIGNvbnN0IGNvbmZpcm1lZCA9IGF3YWl0IHByb21wdGx5LmNvbmZpcm0oXG4gICAgICAgIGBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlOiAke2NoYWxrLmJsdWUoc3RhY2tzLnN0YWNrQXJ0aWZhY3RzLm1hcCgocykgPT4gcy5oaWVyYXJjaGljYWxJZCkuam9pbignLCAnKSl9ICh5L24pP2AsXG4gICAgICApO1xuICAgICAgaWYgKCFjb25maXJtZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFjdGlvbiA9IG9wdGlvbnMuZnJvbURlcGxveSA/ICdkZXBsb3knIDogJ2Rlc3Ryb3knO1xuICAgIGZvciAoY29uc3QgW2luZGV4LCBzdGFja10gb2Ygc3RhY2tzLnN0YWNrQXJ0aWZhY3RzLmVudHJpZXMoKSkge1xuICAgICAgc3VjY2VzcygnJXM6IGRlc3Ryb3lpbmcuLi4gWyVzLyVzXScsIGNoYWxrLmJsdWUoc3RhY2suZGlzcGxheU5hbWUpLCBpbmRleCArIDEsIHN0YWNrcy5zdGFja0NvdW50KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJvcHMuZGVwbG95bWVudHMuZGVzdHJveVN0YWNrKHtcbiAgICAgICAgICBzdGFjayxcbiAgICAgICAgICBkZXBsb3lOYW1lOiBzdGFjay5zdGFja05hbWUsXG4gICAgICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgICB9KTtcbiAgICAgICAgc3VjY2VzcyhgXFxuIOKchSAgJXM6ICR7YWN0aW9ufWVkYCwgY2hhbGsuYmx1ZShzdGFjay5kaXNwbGF5TmFtZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcihgXFxuIOKdjCAgJXM6ICR7YWN0aW9ufSBmYWlsZWRgLCBjaGFsay5ibHVlKHN0YWNrLmRpc3BsYXlOYW1lKSwgZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGxpc3QoXG4gICAgc2VsZWN0b3JzOiBzdHJpbmdbXSxcbiAgICBvcHRpb25zOiB7IGxvbmc/OiBib29sZWFuOyBqc29uPzogYm9vbGVhbjsgc2hvd0RlcHM/OiBib29sZWFuIH0gPSB7fSxcbiAgKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCBsaXN0U3RhY2tzKHRoaXMsIHtcbiAgICAgIHNlbGVjdG9yczogc2VsZWN0b3JzLFxuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMubG9uZyAmJiBvcHRpb25zLnNob3dEZXBzKSB7XG4gICAgICBwcmludFNlcmlhbGl6ZWRPYmplY3Qoc3RhY2tzLCBvcHRpb25zLmpzb24gPz8gZmFsc2UpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2hvd0RlcHMpIHtcbiAgICAgIGNvbnN0IHN0YWNrRGVwcyA9IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgICBzdGFja0RlcHMucHVzaCh7XG4gICAgICAgICAgaWQ6IHN0YWNrLmlkLFxuICAgICAgICAgIGRlcGVuZGVuY2llczogc3RhY2suZGVwZW5kZW5jaWVzLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRTZXJpYWxpemVkT2JqZWN0KHN0YWNrRGVwcywgb3B0aW9ucy5qc29uID8/IGZhbHNlKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxvbmcpIHtcbiAgICAgIGNvbnN0IGxvbmcgPSBbXTtcblxuICAgICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgICAgbG9uZy5wdXNoKHtcbiAgICAgICAgICBpZDogc3RhY2suaWQsXG4gICAgICAgICAgbmFtZTogc3RhY2submFtZSxcbiAgICAgICAgICBlbnZpcm9ubWVudDogc3RhY2suZW52aXJvbm1lbnQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcHJpbnRTZXJpYWxpemVkT2JqZWN0KGxvbmcsIG9wdGlvbnMuanNvbiA/PyBmYWxzZSk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBqdXN0IHByaW50IHN0YWNrIElEc1xuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICBsb2dSZXN1bHQoc3RhY2suaWQpO1xuICAgIH1cblxuICAgIHJldHVybiAwOyAvLyBleGl0LWNvZGVcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aGVzaXplIHRoZSBnaXZlbiBzZXQgb2Ygc3RhY2tzIChjYWxsZWQgd2hlbiB0aGUgdXNlciBydW5zICdjZGsgc3ludGgnKVxuICAgKlxuICAgKiBJTlBVVDogU3RhY2sgbmFtZXMgY2FuIGJlIHN1cHBsaWVkIHVzaW5nIGEgZ2xvYiBmaWx0ZXIuIElmIG5vIHN0YWNrcyBhcmVcbiAgICogZ2l2ZW4sIGFsbCBzdGFja3MgZnJvbSB0aGUgYXBwbGljYXRpb24gYXJlIGltcGxpY2l0bHkgc2VsZWN0ZWQuXG4gICAqXG4gICAqIE9VVFBVVDogSWYgbW9yZSB0aGFuIG9uZSBzdGFjayBlbmRzIHVwIGJlaW5nIHNlbGVjdGVkLCBhbiBvdXRwdXQgZGlyZWN0b3J5XG4gICAqIHNob3VsZCBiZSBzdXBwbGllZCwgd2hlcmUgdGhlIHRlbXBsYXRlcyB3aWxsIGJlIHdyaXR0ZW4uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc3ludGgoXG4gICAgc3RhY2tOYW1lczogc3RyaW5nW10sXG4gICAgZXhjbHVzaXZlbHk6IGJvb2xlYW4sXG4gICAgcXVpZXQ6IGJvb2xlYW4sXG4gICAgYXV0b1ZhbGlkYXRlPzogYm9vbGVhbixcbiAgICBqc29uPzogYm9vbGVhbixcbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCB0aGlzLnNlbGVjdFN0YWNrc0ZvckRpZmYoc3RhY2tOYW1lcywgZXhjbHVzaXZlbHksIGF1dG9WYWxpZGF0ZSk7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGEgc2luZ2xlIHN0YWNrLCBwcmludCBpdCB0byBTVERPVVRcbiAgICBpZiAoc3RhY2tzLnN0YWNrQ291bnQgPT09IDEpIHtcbiAgICAgIGlmICghcXVpZXQpIHtcbiAgICAgICAgcHJpbnRTZXJpYWxpemVkT2JqZWN0KG9ic2N1cmVUZW1wbGF0ZShzdGFja3MuZmlyc3RTdGFjay50ZW1wbGF0ZSksIGpzb24gPz8gZmFsc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBub3Qgb3V0cHV0dGluZyB0ZW1wbGF0ZSB0byBzdGRvdXQsIGxldCdzIGV4cGxhaW4gdGhpbmdzIHRvIHRoZSB1c2VyIGEgbGl0dGxlIGJpdC4uLlxuICAgIHN1Y2Nlc3MoYFN1Y2Nlc3NmdWxseSBzeW50aGVzaXplZCB0byAke2NoYWxrLmJsdWUocGF0aC5yZXNvbHZlKHN0YWNrcy5hc3NlbWJseS5kaXJlY3RvcnkpKX1gKTtcbiAgICBpbmZvKFxuICAgICAgYFN1cHBseSBhIHN0YWNrIGlkICgke3N0YWNrcy5zdGFja0FydGlmYWN0cy5tYXAoKHMpID0+IGNoYWxrLmdyZWVuKHMuaGllcmFyY2hpY2FsSWQpKS5qb2luKCcsICcpfSkgdG8gZGlzcGxheSBpdHMgdGVtcGxhdGUuYCxcbiAgICApO1xuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCb290c3RyYXAgdGhlIENESyBUb29sa2l0IHN0YWNrIGluIHRoZSBhY2NvdW50cyB1c2VkIGJ5IHRoZSBzcGVjaWZpZWQgc3RhY2socykuXG4gICAqXG4gICAqIEBwYXJhbSB1c2VyRW52aXJvbm1lbnRTcGVjcyBlbnZpcm9ubWVudCBuYW1lcyB0aGF0IG5lZWQgdG8gaGF2ZSB0b29sa2l0IHN1cHBvcnRcbiAgICogICAgICAgICAgICAgcHJvdmlzaW9uZWQsIGFzIGEgZ2xvYiBmaWx0ZXIuIElmIG5vbmUgaXMgcHJvdmlkZWQsIGFsbCBzdGFja3MgYXJlIGltcGxpY2l0bHkgc2VsZWN0ZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBuYW1lLCByb2xlIEFSTiwgYm9vdHN0cmFwcGluZyBwYXJhbWV0ZXJzLCBldGMuIHRvIGJlIHVzZWQgZm9yIHRoZSBDREsgVG9vbGtpdCBzdGFjay5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBib290c3RyYXAoXG4gICAgdXNlckVudmlyb25tZW50U3BlY3M6IHN0cmluZ1tdLFxuICAgIG9wdGlvbnM6IEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucyxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgYm9vdHN0cmFwcGVyID0gbmV3IEJvb3RzdHJhcHBlcihvcHRpb25zLnNvdXJjZSwgYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ2Jvb3RzdHJhcCcpKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbiAnLS1hcHAnIGFyZ3VtZW50IGFuZCBhbiBlbnZpcm9ubWVudCBsb29rcyBsaWtlIGEgZ2xvYiwgd2VcbiAgICAvLyBzZWxlY3QgdGhlIGVudmlyb25tZW50cyBmcm9tIHRoZSBhcHAuIE90aGVyd2lzZSwgdXNlIHdoYXQgdGhlIHVzZXIgc2FpZC5cblxuICAgIGNvbnN0IGVudmlyb25tZW50cyA9IGF3YWl0IHRoaXMuZGVmaW5lRW52aXJvbm1lbnRzKHVzZXJFbnZpcm9ubWVudFNwZWNzKTtcblxuICAgIGNvbnN0IGxpbWl0ID0gcExpbWl0KDIwKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAY2RrbGFicy9wcm9taXNlYWxsLW5vLXVuYm91bmRlZC1wYXJhbGxlbGlzbVxuICAgIGF3YWl0IFByb21pc2UuYWxsKGVudmlyb25tZW50cy5tYXAoKGVudmlyb25tZW50KSA9PiBsaW1pdChhc3luYyAoKSA9PiB7XG4gICAgICBzdWNjZXNzKCcg4o+zICBCb290c3RyYXBwaW5nIGVudmlyb25tZW50ICVzLi4uJywgY2hhbGsuYmx1ZShlbnZpcm9ubWVudC5uYW1lKSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBib290c3RyYXBwZXIuYm9vdHN0cmFwRW52aXJvbm1lbnQoZW52aXJvbm1lbnQsIHRoaXMucHJvcHMuc2RrUHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVzdWx0Lm5vT3BcbiAgICAgICAgICA/ICcg4pyFICBFbnZpcm9ubWVudCAlcyBib290c3RyYXBwZWQgKG5vIGNoYW5nZXMpLidcbiAgICAgICAgICA6ICcg4pyFICBFbnZpcm9ubWVudCAlcyBib290c3RyYXBwZWQuJztcbiAgICAgICAgc3VjY2VzcyhtZXNzYWdlLCBjaGFsay5ibHVlKGVudmlyb25tZW50Lm5hbWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IoJyDinYwgIEVudmlyb25tZW50ICVzIGZhaWxlZCBib290c3RyYXBwaW5nOiAlcycsIGNoYWxrLmJsdWUoZW52aXJvbm1lbnQubmFtZSksIGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0pKSk7XG4gIH1cblxuICAvKipcbiAgICogR2FyYmFnZSBjb2xsZWN0cyBhc3NldHMgZnJvbSBhIENESyBhcHAncyBlbnZpcm9ubWVudFxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciBHYXJiYWdlIENvbGxlY3Rpb25cbiAgICovXG4gIHB1YmxpYyBhc3luYyBnYXJiYWdlQ29sbGVjdCh1c2VyRW52aXJvbm1lbnRTcGVjczogc3RyaW5nW10sIG9wdGlvbnM6IEdhcmJhZ2VDb2xsZWN0aW9uT3B0aW9ucykge1xuICAgIGNvbnN0IGVudmlyb25tZW50cyA9IGF3YWl0IHRoaXMuZGVmaW5lRW52aXJvbm1lbnRzKHVzZXJFbnZpcm9ubWVudFNwZWNzKTtcblxuICAgIGZvciAoY29uc3QgZW52aXJvbm1lbnQgb2YgZW52aXJvbm1lbnRzKSB7XG4gICAgICBzdWNjZXNzKCcg4o+zICBHYXJiYWdlIENvbGxlY3RpbmcgZW52aXJvbm1lbnQgJXMuLi4nLCBjaGFsay5ibHVlKGVudmlyb25tZW50Lm5hbWUpKTtcbiAgICAgIGNvbnN0IGdjID0gbmV3IEdhcmJhZ2VDb2xsZWN0b3Ioe1xuICAgICAgICBzZGtQcm92aWRlcjogdGhpcy5wcm9wcy5zZGtQcm92aWRlcixcbiAgICAgICAgaW9IZWxwZXI6IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsICdnYycpLFxuICAgICAgICByZXNvbHZlZEVudmlyb25tZW50OiBlbnZpcm9ubWVudCxcbiAgICAgICAgYm9vdHN0cmFwU3RhY2tOYW1lOiBvcHRpb25zLmJvb3RzdHJhcFN0YWNrTmFtZSxcbiAgICAgICAgcm9sbGJhY2tCdWZmZXJEYXlzOiBvcHRpb25zLnJvbGxiYWNrQnVmZmVyRGF5cyxcbiAgICAgICAgY3JlYXRlZEJ1ZmZlckRheXM6IG9wdGlvbnMuY3JlYXRlZEJ1ZmZlckRheXMsXG4gICAgICAgIGFjdGlvbjogb3B0aW9ucy5hY3Rpb24gPz8gJ2Z1bGwnLFxuICAgICAgICB0eXBlOiBvcHRpb25zLnR5cGUgPz8gJ2FsbCcsXG4gICAgICAgIGNvbmZpcm06IG9wdGlvbnMuY29uZmlybSA/PyB0cnVlLFxuICAgICAgfSk7XG4gICAgICBhd2FpdCBnYy5nYXJiYWdlQ29sbGVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZGVmaW5lRW52aXJvbm1lbnRzKHVzZXJFbnZpcm9ubWVudFNwZWNzOiBzdHJpbmdbXSk6IFByb21pc2U8Y3hhcGkuRW52aXJvbm1lbnRbXT4ge1xuICAgIC8vIEJ5IGRlZmF1bHQsIGdsb2IgZm9yIGV2ZXJ5dGhpbmdcbiAgICBjb25zdCBlbnZpcm9ubWVudFNwZWNzID0gdXNlckVudmlyb25tZW50U3BlY3MubGVuZ3RoID4gMCA/IFsuLi51c2VyRW52aXJvbm1lbnRTcGVjc10gOiBbJyoqJ107XG5cbiAgICAvLyBQYXJ0aXRpb24gaW50byBnbG9icyBhbmQgbm9uLWdsb2JzICh0aGlzIHdpbGwgbXV0YXRlIGVudmlyb25tZW50U3BlY3MpLlxuICAgIGNvbnN0IGdsb2JTcGVjcyA9IHBhcnRpdGlvbihlbnZpcm9ubWVudFNwZWNzLCBsb29rc0xpa2VHbG9iKTtcbiAgICBpZiAoZ2xvYlNwZWNzLmxlbmd0aCA+IDAgJiYgIXRoaXMucHJvcHMuY2xvdWRFeGVjdXRhYmxlLmhhc0FwcCkge1xuICAgICAgaWYgKHVzZXJFbnZpcm9ubWVudFNwZWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gVXNlciBkaWQgcmVxdWVzdCB0aGlzIGdsb2JcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgICBgJyR7Z2xvYlNwZWNzfScgaXMgbm90IGFuIGVudmlyb25tZW50IG5hbWUuIFNwZWNpZnkgYW4gZW52aXJvbm1lbnQgbmFtZSBsaWtlICdhd3M6Ly8xMjM0NTY3ODkwMTIvdXMtZWFzdC0xJywgb3IgcnVuIGluIGEgZGlyZWN0b3J5IHdpdGggJ2Nkay5qc29uJyB0byB1c2Ugd2lsZGNhcmRzLmAsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2VyIGRpZCBub3QgcmVxdWVzdCBhbnl0aGluZ1xuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgICAgIFwiU3BlY2lmeSBhbiBlbnZpcm9ubWVudCBuYW1lIGxpa2UgJ2F3czovLzEyMzQ1Njc4OTAxMi91cy1lYXN0LTEnLCBvciBydW4gaW4gYSBkaXJlY3Rvcnkgd2l0aCAnY2RrLmpzb24nLlwiLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGVudmlyb25tZW50czogY3hhcGkuRW52aXJvbm1lbnRbXSA9IFsuLi5lbnZpcm9ubWVudHNGcm9tRGVzY3JpcHRvcnMoZW52aXJvbm1lbnRTcGVjcyldO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gJy0tYXBwJyBhcmd1bWVudCwgc2VsZWN0IHRoZSBlbnZpcm9ubWVudHMgZnJvbSB0aGUgYXBwLlxuICAgIGlmICh0aGlzLnByb3BzLmNsb3VkRXhlY3V0YWJsZS5oYXNBcHApIHtcbiAgICAgIGVudmlyb25tZW50cy5wdXNoKFxuICAgICAgICAuLi4oYXdhaXQgZ2xvYkVudmlyb25tZW50c0Zyb21TdGFja3MoYXdhaXQgdGhpcy5zZWxlY3RTdGFja3NGb3JMaXN0KFtdKSwgZ2xvYlNwZWNzLCB0aGlzLnByb3BzLnNka1Byb3ZpZGVyKSksXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBlbnZpcm9ubWVudHM7XG4gIH1cblxuICAvKipcbiAgICogTWlncmF0ZXMgYSBDbG91ZEZvcm1hdGlvbiBzdGFjay90ZW1wbGF0ZSB0byBhIENESyBhcHBcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgQ0RLIGFwcCBjcmVhdGlvblxuICAgKi9cbiAgcHVibGljIGFzeW5jIG1pZ3JhdGUob3B0aW9uczogTWlncmF0ZU9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB3YXJuaW5nKCdUaGlzIGNvbW1hbmQgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUuJyk7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBvcHRpb25zLmxhbmd1YWdlPy50b0xvd2VyQ2FzZSgpID8/ICd0eXBlc2NyaXB0JztcbiAgICBjb25zdCBlbnZpcm9ubWVudCA9IHNldEVudmlyb25tZW50KG9wdGlvbnMuYWNjb3VudCwgb3B0aW9ucy5yZWdpb24pO1xuICAgIGxldCBnZW5lcmF0ZVRlbXBsYXRlT3V0cHV0OiBHZW5lcmF0ZVRlbXBsYXRlT3V0cHV0IHwgdW5kZWZpbmVkO1xuICAgIGxldCBjZm46IENmblRlbXBsYXRlR2VuZXJhdG9yUHJvdmlkZXIgfCB1bmRlZmluZWQ7XG4gICAgbGV0IHRlbXBsYXRlVG9EZWxldGU6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICAvLyBpZiBuZWl0aGVyIGZyb21QYXRoIG5vciBmcm9tU3RhY2sgaXMgcHJvdmlkZWQsIGdlbmVyYXRlIGEgdGVtcGxhdGUgdXNpbmcgY2xvdWRmb3JtYXRpb25cbiAgICAgIGNvbnN0IHNjYW5UeXBlID0gcGFyc2VTb3VyY2VPcHRpb25zKG9wdGlvbnMuZnJvbVBhdGgsIG9wdGlvbnMuZnJvbVN0YWNrLCBvcHRpb25zLnN0YWNrTmFtZSkuc291cmNlO1xuICAgICAgaWYgKHNjYW5UeXBlID09IFRlbXBsYXRlU291cmNlT3B0aW9ucy5TQ0FOKSB7XG4gICAgICAgIGdlbmVyYXRlVGVtcGxhdGVPdXRwdXQgPSBhd2FpdCBnZW5lcmF0ZVRlbXBsYXRlKHtcbiAgICAgICAgICBzdGFja05hbWU6IG9wdGlvbnMuc3RhY2tOYW1lLFxuICAgICAgICAgIGZpbHRlcnM6IG9wdGlvbnMuZmlsdGVyLFxuICAgICAgICAgIGZyb21TY2FuOiBvcHRpb25zLmZyb21TY2FuLFxuICAgICAgICAgIHNka1Byb3ZpZGVyOiB0aGlzLnByb3BzLnNka1Byb3ZpZGVyLFxuICAgICAgICAgIGVudmlyb25tZW50OiBlbnZpcm9ubWVudCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRlbXBsYXRlVG9EZWxldGUgPSBnZW5lcmF0ZVRlbXBsYXRlT3V0cHV0LnRlbXBsYXRlSWQ7XG4gICAgICB9IGVsc2UgaWYgKHNjYW5UeXBlID09IFRlbXBsYXRlU291cmNlT3B0aW9ucy5QQVRIKSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlQm9keSA9IHJlYWRGcm9tUGF0aChvcHRpb25zLmZyb21QYXRoISk7XG5cbiAgICAgICAgY29uc3QgcGFyc2VkVGVtcGxhdGUgPSBkZXNlcmlhbGl6ZVN0cnVjdHVyZSh0ZW1wbGF0ZUJvZHkpO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZUlkID0gcGFyc2VkVGVtcGxhdGUuTWV0YWRhdGE/LlRlbXBsYXRlSWQ/LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0ZW1wbGF0ZUlkKSB7XG4gICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIHRlbXBsYXRlIGlkLCB3ZSBjYW4gY2FsbCBkZXNjcmliZSBnZW5lcmF0ZWQgdGVtcGxhdGUgdG8gZ2V0IHRoZSByZXNvdXJjZSBpZGVudGlmaWVyc1xuICAgICAgICAgIC8vIHJlc291cmNlIG1ldGFkYXRhLCBhbmQgdGVtcGxhdGUgc291cmNlIHRvIGdlbmVyYXRlIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgIGNmbiA9IG5ldyBDZm5UZW1wbGF0ZUdlbmVyYXRvclByb3ZpZGVyKGF3YWl0IGJ1aWxkQ2ZuQ2xpZW50KHRoaXMucHJvcHMuc2RrUHJvdmlkZXIsIGVudmlyb25tZW50KSk7XG4gICAgICAgICAgY29uc3QgZ2VuZXJhdGVkVGVtcGxhdGVTdW1tYXJ5ID0gYXdhaXQgY2ZuLmRlc2NyaWJlR2VuZXJhdGVkVGVtcGxhdGUodGVtcGxhdGVJZCk7XG4gICAgICAgICAgZ2VuZXJhdGVUZW1wbGF0ZU91dHB1dCA9IGJ1aWxkR2VuZXJ0ZWRUZW1wbGF0ZU91dHB1dChcbiAgICAgICAgICAgIGdlbmVyYXRlZFRlbXBsYXRlU3VtbWFyeSxcbiAgICAgICAgICAgIHRlbXBsYXRlQm9keSxcbiAgICAgICAgICAgIGdlbmVyYXRlZFRlbXBsYXRlU3VtbWFyeS5HZW5lcmF0ZWRUZW1wbGF0ZUlkISxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlbmVyYXRlVGVtcGxhdGVPdXRwdXQgPSB7XG4gICAgICAgICAgICBtaWdyYXRlSnNvbjoge1xuICAgICAgICAgICAgICB0ZW1wbGF0ZUJvZHk6IHRlbXBsYXRlQm9keSxcbiAgICAgICAgICAgICAgc291cmNlOiAnbG9jYWxmaWxlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzY2FuVHlwZSA9PSBUZW1wbGF0ZVNvdXJjZU9wdGlvbnMuU1RBQ0spIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBhd2FpdCByZWFkRnJvbVN0YWNrKG9wdGlvbnMuc3RhY2tOYW1lLCB0aGlzLnByb3BzLnNka1Byb3ZpZGVyLCBlbnZpcm9ubWVudCk7XG4gICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBObyB0ZW1wbGF0ZSBmb3VuZCBmb3Igc3RhY2stbmFtZTogJHtvcHRpb25zLnN0YWNrTmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBnZW5lcmF0ZVRlbXBsYXRlT3V0cHV0ID0ge1xuICAgICAgICAgIG1pZ3JhdGVKc29uOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZUJvZHk6IHRlbXBsYXRlLFxuICAgICAgICAgICAgc291cmNlOiBvcHRpb25zLnN0YWNrTmFtZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2Ugc2hvdWxkbid0IGV2ZXIgZ2V0IGhlcmUsIGJ1dCBqdXN0IGluIGNhc2UuXG4gICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYEludmFsaWQgc291cmNlIG9wdGlvbiBwcm92aWRlZDogJHtzY2FuVHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YWNrID0gZ2VuZXJhdGVTdGFjayhnZW5lcmF0ZVRlbXBsYXRlT3V0cHV0Lm1pZ3JhdGVKc29uLnRlbXBsYXRlQm9keSwgb3B0aW9ucy5zdGFja05hbWUsIGxhbmd1YWdlKTtcbiAgICAgIHN1Y2Nlc3MoJyDij7MgIEdlbmVyYXRpbmcgQ0RLIGFwcCBmb3IgJXMuLi4nLCBjaGFsay5ibHVlKG9wdGlvbnMuc3RhY2tOYW1lKSk7XG4gICAgICBhd2FpdCBnZW5lcmF0ZUNka0FwcChvcHRpb25zLnN0YWNrTmFtZSwgc3RhY2shLCBsYW5ndWFnZSwgb3B0aW9ucy5vdXRwdXRQYXRoLCBvcHRpb25zLmNvbXByZXNzKTtcbiAgICAgIGlmIChnZW5lcmF0ZVRlbXBsYXRlT3V0cHV0KSB7XG4gICAgICAgIHdyaXRlTWlncmF0ZUpzb25GaWxlKG9wdGlvbnMub3V0cHV0UGF0aCwgb3B0aW9ucy5zdGFja05hbWUsIGdlbmVyYXRlVGVtcGxhdGVPdXRwdXQubWlncmF0ZUpzb24pO1xuICAgICAgfVxuICAgICAgaWYgKGlzVGhlcmVBV2FybmluZyhnZW5lcmF0ZVRlbXBsYXRlT3V0cHV0KSkge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICcg4pqg77iPICBTb21lIHJlc291cmNlcyBjb3VsZCBub3QgYmUgbWlncmF0ZWQgY29tcGxldGVseS4gUGxlYXNlIHJldmlldyB0aGUgUkVBRE1FLm1kIGZpbGUgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgKTtcbiAgICAgICAgYXBwZW5kV2FybmluZ3NUb1JlYWRtZShcbiAgICAgICAgICBgJHtwYXRoLmpvaW4ob3B0aW9ucy5vdXRwdXRQYXRoID8/IHByb2Nlc3MuY3dkKCksIG9wdGlvbnMuc3RhY2tOYW1lKX0vUkVBRE1FLm1kYCxcbiAgICAgICAgICBnZW5lcmF0ZVRlbXBsYXRlT3V0cHV0LnJlc291cmNlcyEsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoJyDinYwgIE1pZ3JhdGUgZmFpbGVkIGZvciBgJXNgOiAlcycsIG9wdGlvbnMuc3RhY2tOYW1lLCAoZSBhcyBFcnJvcikubWVzc2FnZSk7XG4gICAgICB0aHJvdyBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGVtcGxhdGVUb0RlbGV0ZSkge1xuICAgICAgICBpZiAoIWNmbikge1xuICAgICAgICAgIGNmbiA9IG5ldyBDZm5UZW1wbGF0ZUdlbmVyYXRvclByb3ZpZGVyKGF3YWl0IGJ1aWxkQ2ZuQ2xpZW50KHRoaXMucHJvcHMuc2RrUHJvdmlkZXIsIGVudmlyb25tZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5NSUdSQVRFX0lOVEVHX1RFU1QpIHtcbiAgICAgICAgICBhd2FpdCBjZm4uZGVsZXRlR2VuZXJhdGVkVGVtcGxhdGUodGVtcGxhdGVUb0RlbGV0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcmVmYWN0b3Iob3B0aW9uczogUmVmYWN0b3JPcHRpb25zKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBsZXQgZXhjbHVkZTogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAob3B0aW9ucy5leGNsdWRlRmlsZSAhPSBudWxsKSB7XG4gICAgICBpZiAoIShhd2FpdCBmcy5wYXRoRXhpc3RzKG9wdGlvbnMuZXhjbHVkZUZpbGUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBUaGUgZXhjbHVkZSBmaWxlICcke29wdGlvbnMuZXhjbHVkZUZpbGV9JyBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgfVxuICAgICAgZXhjbHVkZSA9IGZzLnJlYWRGaWxlU3luYyhvcHRpb25zLmV4Y2x1ZGVGaWxlKS50b1N0cmluZygndXRmLTgnKS5zcGxpdCgnXFxuJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMudG9vbGtpdC5yZWZhY3Rvcih0aGlzLnByb3BzLmNsb3VkRXhlY3V0YWJsZSwge1xuICAgICAgICBkcnlSdW46IG9wdGlvbnMuZHJ5UnVuLFxuICAgICAgICBleGNsdWRlLFxuICAgICAgICBzdGFja3M6IHtcbiAgICAgICAgICBwYXR0ZXJuczogb3B0aW9ucy5zZWxlY3Rvci5wYXR0ZXJucyxcbiAgICAgICAgICBzdHJhdGVneTogb3B0aW9ucy5zZWxlY3Rvci5wYXR0ZXJucy5sZW5ndGggPiAwID8gU3RhY2tTZWxlY3Rpb25TdHJhdGVneS5QQVRURVJOX01BVENIIDogU3RhY2tTZWxlY3Rpb25TdHJhdGVneS5BTExfU1RBQ0tTLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoKGUgYXMgRXJyb3IpLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHNlbGVjdFN0YWNrc0Zvckxpc3QocGF0dGVybnM6IHN0cmluZ1tdKSB7XG4gICAgY29uc3QgYXNzZW1ibHkgPSBhd2FpdCB0aGlzLmFzc2VtYmx5KCk7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgYXNzZW1ibHkuc2VsZWN0U3RhY2tzKHsgcGF0dGVybnMgfSwgeyBkZWZhdWx0QmVoYXZpb3I6IERlZmF1bHRTZWxlY3Rpb24uQWxsU3RhY2tzIH0pO1xuXG4gICAgLy8gTm8gdmFsaWRhdGlvblxuXG4gICAgcmV0dXJuIHN0YWNrcztcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2VsZWN0U3RhY2tzRm9yRGVwbG95KFxuICAgIHNlbGVjdG9yOiBTdGFja1NlbGVjdG9yLFxuICAgIGV4Y2x1c2l2ZWx5PzogYm9vbGVhbixcbiAgICBjYWNoZUNsb3VkQXNzZW1ibHk/OiBib29sZWFuLFxuICAgIGlnbm9yZU5vU3RhY2tzPzogYm9vbGVhbixcbiAgKTogUHJvbWlzZTxTdGFja0NvbGxlY3Rpb24+IHtcbiAgICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IHRoaXMuYXNzZW1ibHkoY2FjaGVDbG91ZEFzc2VtYmx5KTtcbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCBhc3NlbWJseS5zZWxlY3RTdGFja3Moc2VsZWN0b3IsIHtcbiAgICAgIGV4dGVuZDogZXhjbHVzaXZlbHkgPyBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uLk5vbmUgOiBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uLlVwc3RyZWFtLFxuICAgICAgZGVmYXVsdEJlaGF2aW9yOiBEZWZhdWx0U2VsZWN0aW9uLk9ubHlTaW5nbGUsXG4gICAgICBpZ25vcmVOb1N0YWNrcyxcbiAgICB9KTtcblxuICAgIHRoaXMudmFsaWRhdGVTdGFja3NTZWxlY3RlZChzdGFja3MsIHNlbGVjdG9yLnBhdHRlcm5zKTtcbiAgICBhd2FpdCB0aGlzLnZhbGlkYXRlU3RhY2tzKHN0YWNrcyk7XG5cbiAgICByZXR1cm4gc3RhY2tzO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzZWxlY3RTdGFja3NGb3JEaWZmKFxuICAgIHN0YWNrTmFtZXM6IHN0cmluZ1tdLFxuICAgIGV4Y2x1c2l2ZWx5PzogYm9vbGVhbixcbiAgICBhdXRvVmFsaWRhdGU/OiBib29sZWFuLFxuICApOiBQcm9taXNlPFN0YWNrQ29sbGVjdGlvbj4ge1xuICAgIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgdGhpcy5hc3NlbWJseSgpO1xuXG4gICAgY29uc3Qgc2VsZWN0ZWRGb3JEaWZmID0gYXdhaXQgYXNzZW1ibHkuc2VsZWN0U3RhY2tzKFxuICAgICAgeyBwYXR0ZXJuczogc3RhY2tOYW1lcyB9LFxuICAgICAge1xuICAgICAgICBleHRlbmQ6IGV4Y2x1c2l2ZWx5ID8gRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5Ob25lIDogRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5VcHN0cmVhbSxcbiAgICAgICAgZGVmYXVsdEJlaGF2aW9yOiBEZWZhdWx0U2VsZWN0aW9uLk1haW5Bc3NlbWJseSxcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIGNvbnN0IGFsbFN0YWNrcyA9IGF3YWl0IHRoaXMuc2VsZWN0U3RhY2tzRm9yTGlzdChbXSk7XG4gICAgY29uc3QgYXV0b1ZhbGlkYXRlU3RhY2tzID0gYXV0b1ZhbGlkYXRlXG4gICAgICA/IGFsbFN0YWNrcy5maWx0ZXIoKGFydCkgPT4gYXJ0LnZhbGlkYXRlT25TeW50aCA/PyBmYWxzZSlcbiAgICAgIDogbmV3IFN0YWNrQ29sbGVjdGlvbihhc3NlbWJseSwgW10pO1xuXG4gICAgdGhpcy52YWxpZGF0ZVN0YWNrc1NlbGVjdGVkKHNlbGVjdGVkRm9yRGlmZi5jb25jYXQoYXV0b1ZhbGlkYXRlU3RhY2tzKSwgc3RhY2tOYW1lcyk7XG4gICAgYXdhaXQgdGhpcy52YWxpZGF0ZVN0YWNrcyhzZWxlY3RlZEZvckRpZmYuY29uY2F0KGF1dG9WYWxpZGF0ZVN0YWNrcykpO1xuXG4gICAgcmV0dXJuIHNlbGVjdGVkRm9yRGlmZjtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2VsZWN0U3RhY2tzRm9yRGVzdHJveShzZWxlY3RvcjogU3RhY2tTZWxlY3RvciwgZXhjbHVzaXZlbHk/OiBib29sZWFuKSB7XG4gICAgY29uc3QgYXNzZW1ibHkgPSBhd2FpdCB0aGlzLmFzc2VtYmx5KCk7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgYXNzZW1ibHkuc2VsZWN0U3RhY2tzKHNlbGVjdG9yLCB7XG4gICAgICBleHRlbmQ6IGV4Y2x1c2l2ZWx5ID8gRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5Ob25lIDogRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5Eb3duc3RyZWFtLFxuICAgICAgZGVmYXVsdEJlaGF2aW9yOiBEZWZhdWx0U2VsZWN0aW9uLk9ubHlTaW5nbGUsXG4gICAgfSk7XG5cbiAgICAvLyBObyB2YWxpZGF0aW9uXG5cbiAgICByZXR1cm4gc3RhY2tzO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoZSBzdGFja3MgZm9yIGVycm9ycyBhbmQgd2FybmluZ3MgYWNjb3JkaW5nIHRvIHRoZSBDTEkncyBjdXJyZW50IHNldHRpbmdzXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHZhbGlkYXRlU3RhY2tzKHN0YWNrczogU3RhY2tDb2xsZWN0aW9uKSB7XG4gICAgY29uc3QgZmFpbEF0ID0gdGhpcy52YWxpZGF0ZU1ldGFkYXRhRmFpbEF0KCk7XG4gICAgYXdhaXQgc3RhY2tzLnZhbGlkYXRlTWV0YWRhdGEoZmFpbEF0LCBzdGFja01ldGFkYXRhTG9nZ2VyKHRoaXMucHJvcHMudmVyYm9zZSkpO1xuICB9XG5cbiAgcHJpdmF0ZSB2YWxpZGF0ZU1ldGFkYXRhRmFpbEF0KCk6ICd3YXJuJyB8ICdlcnJvcicgfCAnbm9uZScge1xuICAgIGxldCBmYWlsQXQ6ICd3YXJuJyB8ICdlcnJvcicgfCAnbm9uZScgPSAnZXJyb3InO1xuICAgIGlmICh0aGlzLnByb3BzLmlnbm9yZUVycm9ycykge1xuICAgICAgZmFpbEF0ID0gJ25vbmUnO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wcy5zdHJpY3QpIHtcbiAgICAgIGZhaWxBdCA9ICd3YXJuJztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFpbEF0O1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoYXQgaWYgYSB1c2VyIHNwZWNpZmllZCBhIHN0YWNrIG5hbWUgdGhlcmUgZXhpc3RzIGF0IGxlYXN0IDEgc3RhY2sgc2VsZWN0ZWRcbiAgICovXG4gIHByaXZhdGUgdmFsaWRhdGVTdGFja3NTZWxlY3RlZChzdGFja3M6IFN0YWNrQ29sbGVjdGlvbiwgc3RhY2tOYW1lczogc3RyaW5nW10pIHtcbiAgICBpZiAoc3RhY2tOYW1lcy5sZW5ndGggIT0gMCAmJiBzdGFja3Muc3RhY2tDb3VudCA9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBObyBzdGFja3MgbWF0Y2ggdGhlIG5hbWUocykgJHtzdGFja05hbWVzfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgYSBzaW5nbGUgc3RhY2sgYnkgaXRzIG5hbWVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgc2VsZWN0U2luZ2xlU3RhY2tCeU5hbWUoc3RhY2tOYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IHRoaXMuYXNzZW1ibHkoKTtcblxuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IGFzc2VtYmx5LnNlbGVjdFN0YWNrcyhcbiAgICAgIHsgcGF0dGVybnM6IFtzdGFja05hbWVdIH0sXG4gICAgICB7XG4gICAgICAgIGV4dGVuZDogRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5Ob25lLFxuICAgICAgICBkZWZhdWx0QmVoYXZpb3I6IERlZmF1bHRTZWxlY3Rpb24uTm9uZSxcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIC8vIENvdWxkIGhhdmUgYmVlbiBhIGdsb2Igc28gY2hlY2sgdGhhdCB3ZSBldmFsdWF0ZWQgdG8gZXhhY3RseSBvbmVcbiAgICBpZiAoc3RhY2tzLnN0YWNrQ291bnQgPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBUaGlzIGNvbW1hbmQgcmVxdWlyZXMgZXhhY3RseSBvbmUgc3RhY2sgYW5kIHdlIG1hdGNoZWQgbW9yZSB0aGFuIG9uZTogJHtzdGFja3Muc3RhY2tJZHN9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzc2VtYmx5LnN0YWNrQnlJZChzdGFja3MuZmlyc3RTdGFjay5pZCk7XG4gIH1cblxuICBwdWJsaWMgYXNzZW1ibHkoY2FjaGVDbG91ZEFzc2VtYmx5PzogYm9vbGVhbik6IFByb21pc2U8Q2xvdWRBc3NlbWJseT4ge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNsb3VkRXhlY3V0YWJsZS5zeW50aGVzaXplKGNhY2hlQ2xvdWRBc3NlbWJseSk7XG4gIH1cblxuICBwcml2YXRlIHBhdHRlcm5zQXJyYXlGb3JXYXRjaChcbiAgICBwYXR0ZXJuczogc3RyaW5nIHwgc3RyaW5nW10gfCB1bmRlZmluZWQsXG4gICAgb3B0aW9uczogeyByb290RGlyOiBzdHJpbmc7IHJldHVyblJvb3REaXJJZkVtcHR5OiBib29sZWFuIH0sXG4gICk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBwYXR0ZXJuc0FycmF5OiBzdHJpbmdbXSA9IHBhdHRlcm5zICE9PSB1bmRlZmluZWQgPyAoQXJyYXkuaXNBcnJheShwYXR0ZXJucykgPyBwYXR0ZXJucyA6IFtwYXR0ZXJuc10pIDogW107XG4gICAgcmV0dXJuIHBhdHRlcm5zQXJyYXkubGVuZ3RoID4gMCA/IHBhdHRlcm5zQXJyYXkgOiBvcHRpb25zLnJldHVyblJvb3REaXJJZkVtcHR5ID8gW29wdGlvbnMucm9vdERpcl0gOiBbXTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW52b2tlRGVwbG95RnJvbVdhdGNoKFxuICAgIG9wdGlvbnM6IFdhdGNoT3B0aW9ucyxcbiAgICBjbG91ZFdhdGNoTG9nTW9uaXRvcj86IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGRlcGxveU9wdGlvbnM6IERlcGxveU9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcmVxdWlyZUFwcHJvdmFsOiBSZXF1aXJlQXBwcm92YWwuTkVWRVIsXG4gICAgICAvLyBpZiAnd2F0Y2gnIGlzIGNhbGxlZCBieSBpbnZva2luZyAnY2RrIGRlcGxveSAtLXdhdGNoJyxcbiAgICAgIC8vIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRvIG5vdCBjYWxsICdkZXBsb3knIHdpdGggJ3dhdGNoJyBhZ2FpbixcbiAgICAgIC8vIGFzIHRoYXQgd291bGQgbGVhZCB0byBhIGN5Y2xlXG4gICAgICB3YXRjaDogZmFsc2UsXG4gICAgICBjbG91ZFdhdGNoTG9nTW9uaXRvcixcbiAgICAgIGNhY2hlQ2xvdWRBc3NlbWJseTogZmFsc2UsXG4gICAgICBob3Rzd2FwOiBvcHRpb25zLmhvdHN3YXAsXG4gICAgICBleHRyYVVzZXJBZ2VudDogYGNkay13YXRjaC9ob3Rzd2FwLSR7b3B0aW9ucy5ob3Rzd2FwICE9PSBIb3Rzd2FwTW9kZS5GQUxMX0JBQ0sgPyAnb24nIDogJ29mZid9YCxcbiAgICAgIGNvbmN1cnJlbmN5OiBvcHRpb25zLmNvbmN1cnJlbmN5LFxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5kZXBsb3koZGVwbG95T3B0aW9ucyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBqdXN0IGNvbnRpbnVlIC0gZGVwbG95IHdpbGwgc2hvdyB0aGUgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBhc3NldCBwdWJsaXNoaW5nIGFuZCBidWlsZGluZyBmcm9tIHRoZSB3b3JrIGdyYXBoIGZvciBhc3NldHMgdGhhdCBhcmUgYWxyZWFkeSBpbiBwbGFjZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyByZW1vdmVQdWJsaXNoZWRBc3NldHMoZ3JhcGg6IFdvcmtHcmFwaCwgb3B0aW9uczogRGVwbG95T3B0aW9ucykge1xuICAgIGF3YWl0IGdyYXBoLnJlbW92ZVVubmVjZXNzYXJ5QXNzZXRzKGFzc2V0Tm9kZSA9PiB0aGlzLnByb3BzLmRlcGxveW1lbnRzLmlzU2luZ2xlQXNzZXRQdWJsaXNoZWQoYXNzZXROb2RlLmFzc2V0TWFuaWZlc3QsIGFzc2V0Tm9kZS5hc3NldCwge1xuICAgICAgc3RhY2s6IGFzc2V0Tm9kZS5wYXJlbnRTdGFjayxcbiAgICAgIHJvbGVBcm46IG9wdGlvbnMucm9sZUFybixcbiAgICAgIHN0YWNrTmFtZTogYXNzZXROb2RlLnBhcmVudFN0YWNrLnN0YWNrTmFtZSxcbiAgICB9KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcmludCBhIHNlcmlhbGl6ZWQgb2JqZWN0IChZQU1MIG9yIEpTT04pIHRvIHN0ZG91dC5cbiAqL1xuZnVuY3Rpb24gcHJpbnRTZXJpYWxpemVkT2JqZWN0KG9iajogYW55LCBqc29uOiBib29sZWFuKSB7XG4gIGxvZ1Jlc3VsdChzZXJpYWxpemVTdHJ1Y3R1cmUob2JqLCBqc29uKSk7XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgdGhlIGRpZmYgY29tbWFuZFxuICovXG5leHBvcnQgaW50ZXJmYWNlIERpZmZPcHRpb25zIHtcbiAgLyoqXG4gICAqIFN0YWNrIG5hbWVzIHRvIGRpZmZcbiAgICovXG4gIHJlYWRvbmx5IHN0YWNrTmFtZXM6IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSB0b29sa2l0IHN0YWNrLCBpZiBub3QgdGhlIGRlZmF1bHQgbmFtZVxuICAgKlxuICAgKiBAZGVmYXVsdCAnQ0RLVG9vbGtpdCdcbiAgICovXG4gIHJlYWRvbmx5IHRvb2xraXRTdGFja05hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE9ubHkgc2VsZWN0IHRoZSBnaXZlbiBzdGFja1xuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgZXhjbHVzaXZlbHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBVc2VkIGEgdGVtcGxhdGUgZnJvbSBkaXNrIGluc3RlYWQgb2YgZnJvbSB0aGUgc2VydmVyXG4gICAqXG4gICAqIEBkZWZhdWx0IFVzZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICovXG4gIHJlYWRvbmx5IHRlbXBsYXRlUGF0aD86IHN0cmluZztcblxuICAvKipcbiAgICogU3RyaWN0IGRpZmYgbW9kZVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgc3RyaWN0PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSG93IG1hbnkgbGluZXMgb2YgY29udGV4dCB0byBzaG93IGluIHRoZSBkaWZmXG4gICAqXG4gICAqIEBkZWZhdWx0IDNcbiAgICovXG4gIHJlYWRvbmx5IGNvbnRleHRMaW5lcz86IG51bWJlcjtcblxuICAvKipcbiAgICogV2hldGhlciB0byBmYWlsIHdpdGggZXhpdCBjb2RlIDEgaW4gY2FzZSBvZiBkaWZmXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBmYWlsPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogT25seSBydW4gZGlmZiBvbiBicm9hZGVuZWQgc2VjdXJpdHkgY2hhbmdlc1xuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgc2VjdXJpdHlPbmx5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0byBydW4gdGhlIGRpZmYgYWdhaW5zdCB0aGUgdGVtcGxhdGUgYWZ0ZXIgdGhlIENsb3VkRm9ybWF0aW9uIFRyYW5zZm9ybXMgaW5zaWRlIGl0IGhhdmUgYmVlbiBleGVjdXRlZFxuICAgKiAoYXMgb3Bwb3NlZCB0byB0aGUgb3JpZ2luYWwgdGVtcGxhdGUsIHRoZSBkZWZhdWx0LCB3aGljaCBjb250YWlucyB0aGUgdW5wcm9jZXNzZWQgVHJhbnNmb3JtcykuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBjb21wYXJlQWdhaW5zdFByb2Nlc3NlZFRlbXBsYXRlPzogYm9vbGVhbjtcblxuICAvKlxuICAgKiBSdW4gZGlmZiBpbiBxdWlldCBtb2RlIHdpdGhvdXQgcHJpbnRpbmcgdGhlIGRpZmYgc3RhdHVzZXNcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IHF1aWV0PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZvciBDbG91ZEZvcm1hdGlvbiBhdCBkaWZmIHRpbWUsIHVzZWQgdG8gY3JlYXRlIGEgY2hhbmdlIHNldFxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgcmVhZG9ubHkgcGFyYW1ldGVycz86IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZCB9O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0byBjcmVhdGUsIGFuYWx5emUsIGFuZCBzdWJzZXF1ZW50bHkgZGVsZXRlIGEgY2hhbmdlc2V0XG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IGNoYW5nZVNldD86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBDZm5EZXBsb3lPcHRpb25zIHtcbiAgLyoqXG4gICAqIENyaXRlcmlhIGZvciBzZWxlY3Rpbmcgc3RhY2tzIHRvIGRlcGxveVxuICAgKi9cbiAgc2VsZWN0b3I6IFN0YWNrU2VsZWN0b3I7XG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIHRvb2xraXQgc3RhY2sgdG8gdXNlL2RlcGxveVxuICAgKlxuICAgKiBAZGVmYXVsdCBDREtUb29sa2l0XG4gICAqL1xuICB0b29sa2l0U3RhY2tOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSb2xlIHRvIHBhc3MgdG8gQ2xvdWRGb3JtYXRpb24gZm9yIGRlcGxveW1lbnRcbiAgICovXG4gIHJvbGVBcm4/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIG5hbWUgdG8gdXNlIGZvciB0aGUgQ2xvdWRGb3JtYXRpb24gY2hhbmdlIHNldC5cbiAgICogSWYgbm90IHByb3ZpZGVkLCBhIG5hbWUgd2lsbCBiZSBnZW5lcmF0ZWQgYXV0b21hdGljYWxseS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlICdkZXBsb3ltZW50TWV0aG9kJyBpbnN0ZWFkXG4gICAqL1xuICBjaGFuZ2VTZXROYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGV4ZWN1dGUgdGhlIENoYW5nZVNldFxuICAgKiBOb3QgcHJvdmlkaW5nIGBleGVjdXRlYCBwYXJhbWV0ZXIgd2lsbCByZXN1bHQgaW4gZXhlY3V0aW9uIG9mIENoYW5nZVNldFxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqIEBkZXByZWNhdGVkIFVzZSAnZGVwbG95bWVudE1ldGhvZCcgaW5zdGVhZFxuICAgKi9cbiAgZXhlY3V0ZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERlcGxveW1lbnQgbWV0aG9kXG4gICAqL1xuICByZWFkb25seSBkZXBsb3ltZW50TWV0aG9kPzogRGVwbG95bWVudE1ldGhvZDtcblxuICAvKipcbiAgICogRGlzcGxheSBtb2RlIGZvciBzdGFjayBkZXBsb3ltZW50IHByb2dyZXNzLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5CYXIgLSBzdGFjayBldmVudHMgd2lsbCBiZSBkaXNwbGF5ZWQgZm9yXG4gICAqICAgdGhlIHJlc291cmNlIGN1cnJlbnRseSBiZWluZyBkZXBsb3llZC5cbiAgICovXG4gIHByb2dyZXNzPzogU3RhY2tBY3Rpdml0eVByb2dyZXNzO1xuXG4gIC8qKlxuICAgKiBSb2xsYmFjayBmYWlsZWQgZGVwbG95bWVudHNcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgcm9sbGJhY2s/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgV2F0Y2hPcHRpb25zIGV4dGVuZHMgT21pdDxDZm5EZXBsb3lPcHRpb25zLCAnZXhlY3V0ZSc+IHtcbiAgLyoqXG4gICAqIE9ubHkgc2VsZWN0IHRoZSBnaXZlbiBzdGFja1xuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZXhjbHVzaXZlbHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSZXVzZSB0aGUgYXNzZXRzIHdpdGggdGhlIGdpdmVuIGFzc2V0IElEc1xuICAgKi9cbiAgcmV1c2VBc3NldHM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogQWx3YXlzIGRlcGxveSwgZXZlbiBpZiB0ZW1wbGF0ZXMgYXJlIGlkZW50aWNhbC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGZvcmNlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0byBwZXJmb3JtIGEgJ2hvdHN3YXAnIGRlcGxveW1lbnQuXG4gICAqIEEgJ2hvdHN3YXAnIGRlcGxveW1lbnQgd2lsbCBhdHRlbXB0IHRvIHNob3J0LWNpcmN1aXQgQ2xvdWRGb3JtYXRpb25cbiAgICogYW5kIHVwZGF0ZSB0aGUgYWZmZWN0ZWQgcmVzb3VyY2VzIGxpa2UgTGFtYmRhIGZ1bmN0aW9ucyBkaXJlY3RseS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBgSG90c3dhcE1vZGUuRkFMTF9CQUNLYCBmb3IgcmVndWxhciBkZXBsb3ltZW50cywgYEhvdHN3YXBNb2RlLkhPVFNXQVBfT05MWWAgZm9yICd3YXRjaCcgZGVwbG95bWVudHNcbiAgICovXG4gIHJlYWRvbmx5IGhvdHN3YXA6IEhvdHN3YXBNb2RlO1xuXG4gIC8qKlxuICAgKiBUaGUgZXh0cmEgc3RyaW5nIHRvIGFwcGVuZCB0byB0aGUgVXNlci1BZ2VudCBoZWFkZXIgd2hlbiBwZXJmb3JtaW5nIEFXUyBTREsgY2FsbHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gbm90aGluZyBleHRyYSBpcyBhcHBlbmRlZCB0byB0aGUgVXNlci1BZ2VudCBoZWFkZXJcbiAgICovXG4gIHJlYWRvbmx5IGV4dHJhVXNlckFnZW50Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHNob3cgQ2xvdWRXYXRjaCBsb2dzIGZvciBob3Rzd2FwcGVkIHJlc291cmNlc1xuICAgKiBsb2NhbGx5IGluIHRoZSB1c2VycyB0ZXJtaW5hbFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGZhbHNlXG4gICAqL1xuICByZWFkb25seSB0cmFjZUxvZ3M/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiBzaW11bHRhbmVvdXMgZGVwbG95bWVudHMgKGRlcGVuZGVuY3kgcGVybWl0dGluZykgdG8gZXhlY3V0ZS5cbiAgICogVGhlIGRlZmF1bHQgaXMgJzEnLCB3aGljaCBleGVjdXRlcyBhbGwgZGVwbG95bWVudHMgc2VyaWFsbHkuXG4gICAqXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIHJlYWRvbmx5IGNvbmN1cnJlbmN5PzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlcGxveU9wdGlvbnMgZXh0ZW5kcyBDZm5EZXBsb3lPcHRpb25zLCBXYXRjaE9wdGlvbnMge1xuICAvKipcbiAgICogQVJOcyBvZiBTTlMgdG9waWNzIHRoYXQgQ2xvdWRGb3JtYXRpb24gd2lsbCBub3RpZnkgd2l0aCBzdGFjayByZWxhdGVkIGV2ZW50c1xuICAgKi9cbiAgbm90aWZpY2F0aW9uQXJucz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBXaGF0IGtpbmQgb2Ygc2VjdXJpdHkgY2hhbmdlcyByZXF1aXJlIGFwcHJvdmFsXG4gICAqXG4gICAqIEBkZWZhdWx0IFJlcXVpcmVBcHByb3ZhbC5Ccm9hZGVuaW5nXG4gICAqL1xuICByZXF1aXJlQXBwcm92YWw/OiBSZXF1aXJlQXBwcm92YWw7XG5cbiAgLyoqXG4gICAqIFRhZ3MgdG8gcGFzcyB0byBDbG91ZEZvcm1hdGlvbiBmb3IgZGVwbG95bWVudFxuICAgKi9cbiAgdGFncz86IFRhZ1tdO1xuXG4gIC8qKlxuICAgKiBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIENsb3VkRm9ybWF0aW9uIGF0IGRlcGxveSB0aW1lXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqL1xuICBwYXJhbWV0ZXJzPzogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH07XG5cbiAgLyoqXG4gICAqIFVzZSBwcmV2aW91cyB2YWx1ZXMgZm9yIHVuc3BlY2lmaWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogSWYgbm90IHNldCwgYWxsIHBhcmFtZXRlcnMgbXVzdCBiZSBzcGVjaWZpZWQgZm9yIGV2ZXJ5IGRlcGxveW1lbnQuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHVzZVByZXZpb3VzUGFyYW1ldGVycz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFBhdGggdG8gZmlsZSB3aGVyZSBzdGFjayBvdXRwdXRzIHdpbGwgYmUgd3JpdHRlbiBhZnRlciBhIHN1Y2Nlc3NmdWwgZGVwbG95IGFzIEpTT05cbiAgICogQGRlZmF1bHQgLSBPdXRwdXRzIGFyZSBub3Qgd3JpdHRlbiB0byBhbnkgZmlsZVxuICAgKi9cbiAgb3V0cHV0c0ZpbGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgd2UgYXJlIG9uIGEgQ0kgc3lzdGVtXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBjaT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyAnZGVwbG95JyBjb21tYW5kIHNob3VsZCBhY3R1YWxseSBkZWxlZ2F0ZSB0byB0aGUgJ3dhdGNoJyBjb21tYW5kLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgd2F0Y2g/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIHNob3VsZCBjYWNoZSB0aGUgQ2xvdWQgQXNzZW1ibHkgYWZ0ZXIgdGhlIGZpcnN0IHRpbWUgaXQgaGFzIGJlZW4gc3ludGhlc2l6ZWQuXG4gICAqIFRoZSBkZWZhdWx0IGlzICd0cnVlJywgd2Ugb25seSBkb24ndCB3YW50IHRvIGRvIGl0IGluIGNhc2UgdGhlIGRlcGxveW1lbnQgaXMgdHJpZ2dlcmVkIGJ5XG4gICAqICdjZGsgd2F0Y2gnLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBjYWNoZUNsb3VkQXNzZW1ibHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBbGxvd3MgYWRkaW5nIENsb3VkV2F0Y2ggbG9nIGdyb3VwcyB0byB0aGUgbG9nIG1vbml0b3IgdmlhXG4gICAqIGNsb3VkV2F0Y2hMb2dNb25pdG9yLnNldExvZ0dyb3VwcygpO1xuICAgKlxuICAgKiBAZGVmYXVsdCAtIG5vdCBtb25pdG9yaW5nIENsb3VkV2F0Y2ggbG9nc1xuICAgKi9cbiAgcmVhZG9ubHkgY2xvdWRXYXRjaExvZ01vbml0b3I/OiBDbG91ZFdhdGNoTG9nRXZlbnRNb25pdG9yO1xuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiBzaW11bHRhbmVvdXMgZGVwbG95bWVudHMgKGRlcGVuZGVuY3kgcGVybWl0dGluZykgdG8gZXhlY3V0ZS5cbiAgICogVGhlIGRlZmF1bHQgaXMgJzEnLCB3aGljaCBleGVjdXRlcyBhbGwgZGVwbG95bWVudHMgc2VyaWFsbHkuXG4gICAqXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIHJlYWRvbmx5IGNvbmN1cnJlbmN5PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBCdWlsZC9wdWJsaXNoIGFzc2V0cyBmb3IgYSBzaW5nbGUgc3RhY2sgaW4gcGFyYWxsZWxcbiAgICpcbiAgICogSW5kZXBlbmRlbnQgb2Ygd2hldGhlciBzdGFja3MgYXJlIGJlaW5nIGRvbmUgaW4gcGFyYWxsZWwgb3Igbm8uXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IGFzc2V0UGFyYWxsZWxpc20/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGVuIHRvIGJ1aWxkIGFzc2V0c1xuICAgKlxuICAgKiBUaGUgZGVmYXVsdCBpcyB0aGUgRG9ja2VyLWZyaWVuZGx5IGRlZmF1bHQuXG4gICAqXG4gICAqIEBkZWZhdWx0IEFzc2V0QnVpbGRUaW1lLkFMTF9CRUZPUkVfREVQTE9ZXG4gICAqL1xuICByZWFkb25seSBhc3NldEJ1aWxkVGltZT86IEFzc2V0QnVpbGRUaW1lO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGRlcGxveSBpZiB0aGUgYXBwIGNvbnRhaW5zIG5vIHN0YWNrcy5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGlnbm9yZU5vU3RhY2tzPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb2xsYmFja09wdGlvbnMge1xuICAvKipcbiAgICogQ3JpdGVyaWEgZm9yIHNlbGVjdGluZyBzdGFja3MgdG8gZGVwbG95XG4gICAqL1xuICByZWFkb25seSBzZWxlY3RvcjogU3RhY2tTZWxlY3RvcjtcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgdG9vbGtpdCBzdGFjayB0byB1c2UvZGVwbG95XG4gICAqXG4gICAqIEBkZWZhdWx0IENES1Rvb2xraXRcbiAgICovXG4gIHJlYWRvbmx5IHRvb2xraXRTdGFja05hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJvbGUgdG8gcGFzcyB0byBDbG91ZEZvcm1hdGlvbiBmb3IgZGVwbG95bWVudFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIERlZmF1bHQgc3RhY2sgcm9sZVxuICAgKi9cbiAgcmVhZG9ubHkgcm9sZUFybj86IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciB0byBmb3JjZSB0aGUgcm9sbGJhY2sgb3Igbm90XG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBmb3JjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIExvZ2ljYWwgSURzIG9mIHJlc291cmNlcyB0byBvcnBoYW5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBvcnBoYW5pbmdcbiAgICovXG4gIHJlYWRvbmx5IG9ycGhhbkxvZ2ljYWxJZHM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogV2hldGhlciB0byB2YWxpZGF0ZSB0aGUgdmVyc2lvbiBvZiB0aGUgYm9vdHN0cmFwIHN0YWNrIHBlcm1pc3Npb25zXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHZhbGlkYXRlQm9vdHN0cmFwU3RhY2tWZXJzaW9uPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbXBvcnRPcHRpb25zIGV4dGVuZHMgQ2ZuRGVwbG95T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBCdWlsZCBhIHBoeXNpY2FsIHJlc291cmNlIG1hcHBpbmcgYW5kIHdyaXRlIGl0IHRvIHRoZSBnaXZlbiBmaWxlLCB3aXRob3V0IHBlcmZvcm1pbmcgdGhlIGFjdHVhbCBpbXBvcnQgb3BlcmF0aW9uXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gZmlsZVxuICAgKi9cblxuICByZWFkb25seSByZWNvcmRSZXNvdXJjZU1hcHBpbmc/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFBhdGggdG8gYSBmaWxlIHdpdGggdGhlIHBoeXNpY2FsIHJlc291cmNlIG1hcHBpbmcgdG8gQ0RLIGNvbnN0cnVjdHMgaW4gSlNPTiBmb3JtYXRcbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBtYXBwaW5nIGZpbGVcbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlTWFwcGluZ0ZpbGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFsbG93IG5vbi1hZGRpdGlvbiBjaGFuZ2VzIHRvIHRoZSB0ZW1wbGF0ZVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgZm9yY2U/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlc3Ryb3lPcHRpb25zIHtcbiAgLyoqXG4gICAqIENyaXRlcmlhIGZvciBzZWxlY3Rpbmcgc3RhY2tzIHRvIGRlcGxveVxuICAgKi9cbiAgc2VsZWN0b3I6IFN0YWNrU2VsZWN0b3I7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZXhjbHVkZSBzdGFja3MgdGhhdCBkZXBlbmQgb24gdGhlIHN0YWNrcyB0byBiZSBkZWxldGVkXG4gICAqL1xuICBleGNsdXNpdmVseTogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0byBza2lwIHByb21wdGluZyBmb3IgY29uZmlybWF0aW9uXG4gICAqL1xuICBmb3JjZTogYm9vbGVhbjtcblxuICAvKipcbiAgICogVGhlIGFybiBvZiB0aGUgSUFNIHJvbGUgdG8gdXNlXG4gICAqL1xuICByb2xlQXJuPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBkZXN0cm95IHJlcXVlc3QgY2FtZSBmcm9tIGEgZGVwbG95LlxuICAgKi9cbiAgZnJvbURlcGxveT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgdGhlIGdhcmJhZ2UgY29sbGVjdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdhcmJhZ2VDb2xsZWN0aW9uT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgYWN0aW9uIHRvIHBlcmZvcm0uXG4gICAqXG4gICAqIEBkZWZhdWx0ICdmdWxsJ1xuICAgKi9cbiAgcmVhZG9ubHkgYWN0aW9uOiAncHJpbnQnIHwgJ3RhZycgfCAnZGVsZXRlLXRhZ2dlZCcgfCAnZnVsbCc7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBhc3NldHMgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0ICdhbGwnXG4gICAqL1xuICByZWFkb25seSB0eXBlOiAnczMnIHwgJ2VjcicgfCAnYWxsJztcblxuICAvKipcbiAgICogRWxhcHNlZCB0aW1lIGJldHdlZW4gYW4gYXNzZXQgYmVpbmcgbWFya2VkIGFzIGlzb2xhdGVkIGFuZCBhY3R1YWxseSBkZWxldGVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICByZWFkb25seSByb2xsYmFja0J1ZmZlckRheXM6IG51bWJlcjtcblxuICAvKipcbiAgICogUmVmdXNlIGRlbGV0aW9uIG9mIGFueSBhc3NldHMgeW91bmdlciB0aGFuIHRoaXMgbnVtYmVyIG9mIGRheXMuXG4gICAqL1xuICByZWFkb25seSBjcmVhdGVkQnVmZmVyRGF5czogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhY2sgbmFtZSBvZiB0aGUgYm9vdHN0cmFwIHN0YWNrLlxuICAgKlxuICAgKiBAZGVmYXVsdCBERUZBVUxUX1RPT0xLSVRfU1RBQ0tfTkFNRVxuICAgKi9cbiAgcmVhZG9ubHkgYm9vdHN0cmFwU3RhY2tOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTa2lwcyB0aGUgcHJvbXB0IGJlZm9yZSBhY3R1YWwgZGVsZXRpb24gYmVnaW5zXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBjb25maXJtPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNaWdyYXRlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBhc3NpZ25lZCB0byB0aGUgZ2VuZXJhdGVkIHN0YWNrLiBUaGlzIGlzIGFsc28gdXNlZCB0byBnZXRcbiAgICogdGhlIHN0YWNrIGZyb20gdGhlIHVzZXIncyBhY2NvdW50IGlmIGAtLWZyb20tc3RhY2tgIGlzIHVzZWQuXG4gICAqL1xuICByZWFkb25seSBzdGFja05hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHRhcmdldCBsYW5ndWFnZSBmb3IgdGhlIGdlbmVyYXRlZCB0aGUgQ0RLIGFwcC5cbiAgICpcbiAgICogQGRlZmF1bHQgdHlwZXNjcmlwdFxuICAgKi9cbiAgcmVhZG9ubHkgbGFuZ3VhZ2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBsb2NhbCBwYXRoIG9mIHRoZSB0ZW1wbGF0ZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBDREsgYXBwLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIExvY2FsIHBhdGggaXMgbm90IHVzZWQgZm9yIHRoZSB0ZW1wbGF0ZSBzb3VyY2UuXG4gICAqL1xuICByZWFkb25seSBmcm9tUGF0aD86IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciB0byBnZXQgdGhlIHRlbXBsYXRlIGZyb20gYW4gZXhpc3RpbmcgQ2xvdWRGb3JtYXRpb24gc3RhY2suXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBmcm9tU3RhY2s/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgb3V0cHV0IHBhdGggYXQgd2hpY2ggdG8gY3JlYXRlIHRoZSBDREsgYXBwLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFRoZSBjdXJyZW50IGRpcmVjdG9yeVxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0UGF0aD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGFjY291bnQgZnJvbSB3aGljaCB0byByZXRyaWV2ZSB0aGUgdGVtcGxhdGUgb2YgdGhlIENsb3VkRm9ybWF0aW9uIHN0YWNrLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFVzZXMgdGhlIGFjY291bnQgZm9yIHRoZSBjcmVkZW50aWFscyBpbiB1c2UgYnkgdGhlIHVzZXIuXG4gICAqL1xuICByZWFkb25seSBhY2NvdW50Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVnaW9uIGZyb20gd2hpY2ggdG8gcmV0cmlldmUgdGhlIHRlbXBsYXRlIG9mIHRoZSBDbG91ZEZvcm1hdGlvbiBzdGFjay5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBVc2VzIHRoZSBkZWZhdWx0IHJlZ2lvbiBmb3IgdGhlIGNyZWRlbnRpYWxzIGluIHVzZSBieSB0aGUgdXNlci5cbiAgICovXG4gIHJlYWRvbmx5IHJlZ2lvbj86IHN0cmluZztcblxuICAvKipcbiAgICogRmlsdGVyaW5nIGNyaXRlcmlhIHVzZWQgdG8gc2VsZWN0IHRoZSByZXNvdXJjZXMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIGdlbmVyYXRlZCBDREsgYXBwLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIEluY2x1ZGUgYWxsIHJlc291cmNlc1xuICAgKi9cbiAgcmVhZG9ubHkgZmlsdGVyPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gaW5pdGlhdGUgYSBuZXcgYWNjb3VudCBzY2FuIGZvciBnZW5lcmF0aW5nIHRoZSBDREsgYXBwLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgZnJvbVNjYW4/OiBGcm9tU2NhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0byB6aXAgdGhlIGdlbmVyYXRlZCBjZGsgYXBwIGZvbGRlci5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGNvbXByZXNzPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWZhY3Rvck9wdGlvbnMge1xuICAvKipcbiAgICogV2hldGhlciB0byBvbmx5IHNob3cgdGhlIHByb3Bvc2VkIHJlZmFjdG9yLCB3aXRob3V0IGFwcGx5aW5nIGl0XG4gICAqL1xuICByZWFkb25seSBkcnlSdW46IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIENyaXRlcmlhIGZvciBzZWxlY3Rpbmcgc3RhY2tzIHRvIGRlcGxveVxuICAgKi9cbiAgc2VsZWN0b3I6IFN0YWNrU2VsZWN0b3I7XG5cbiAgLyoqXG4gICAqIFRoZSBhYnNvbHV0ZSBwYXRoIHRvIGEgZmlsZSB0aGF0IGNvbnRhaW5zIGEgbGlzdCBvZiByZXNvdXJjZXMgdGhhdFxuICAgKiBzaG91bGQgYmUgZXhjbHVkZWQgZHVyaW5nIHRoZSByZWZhY3Rvci4gVGhpcyBmaWxlIHNob3VsZCBjb250YWluIGFcbiAgICogbmV3bGluZSBzZXBhcmF0ZWQgbGlzdCBvZiBfZGVzdGluYXRpb25fIGxvY2F0aW9ucyB0byBleGNsdWRlLCBpLmUuLFxuICAgKiB0aGUgbG9jYXRpb24gdG8gd2hpY2ggYSByZXNvdXJjZSB3b3VsZCBiZSBtb3ZlZCBpZiB0aGUgcmVmYWN0b3JcbiAgICogd2VyZSB0byBoYXBwZW4uXG4gICAqXG4gICAqIFRoZSBmb3JtYXQgb2YgdGhlIGxvY2F0aW9ucyBpbiB0aGUgZmlsZSBjYW4gYmUgZWl0aGVyOlxuICAgKlxuICAgKiAtIFN0YWNrIG5hbWUgYW5kIGxvZ2ljYWwgSUQgKGUuZy4gYFN0YWNrMS5NeVF1ZXVlYClcbiAgICogLSBBIGNvbnN0cnVjdCBwYXRoIChlLmcuIGBTdGFjazEvRm9vL0Jhci9SZXNvdXJjZWApLlxuICAgKi9cbiAgZXhjbHVkZUZpbGU/OiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1ldGVyTWFwKFxuICBwYXJhbWV0ZXJzOlxuICB8IHtcbiAgICBbbmFtZTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICB9XG4gIHwgdW5kZWZpbmVkLFxuKTogeyBbbmFtZTogc3RyaW5nXTogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH0gfSB7XG4gIGNvbnN0IHBhcmFtZXRlck1hcDoge1xuICAgIFtuYW1lOiBzdHJpbmddOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfTtcbiAgfSA9IHsgJyonOiB7fSB9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbWV0ZXJzKSB7XG4gICAgaWYgKHBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29uc3QgW3N0YWNrLCBwYXJhbWV0ZXJdID0ga2V5LnNwbGl0KCc6JywgMik7XG4gICAgICBpZiAoIXBhcmFtZXRlcikge1xuICAgICAgICBwYXJhbWV0ZXJNYXBbJyonXVtzdGFja10gPSBwYXJhbWV0ZXJzW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXBhcmFtZXRlck1hcFtzdGFja10pIHtcbiAgICAgICAgICBwYXJhbWV0ZXJNYXBbc3RhY2tdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1ldGVyTWFwW3N0YWNrXVtwYXJhbWV0ZXJdID0gcGFyYW1ldGVyc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJhbWV0ZXJNYXA7XG59XG5cbi8qKlxuICogQXNrIHRoZSB1c2VyIGZvciBhIHllcy9ubyBjb25maXJtYXRpb25cbiAqXG4gKiBBdXRvbWF0aWNhbGx5IGZhaWwgdGhlIGNvbmZpcm1hdGlvbiBpbiBjYXNlIHdlJ3JlIGluIGEgc2l0dWF0aW9uIHdoZXJlIHRoZSBjb25maXJtYXRpb25cbiAqIGNhbm5vdCBiZSBpbnRlcmFjdGl2ZWx5IG9idGFpbmVkIGZyb20gYSBodW1hbiBhdCB0aGUga2V5Ym9hcmQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFza1VzZXJDb25maXJtYXRpb24oXG4gIGlvSG9zdDogQ2xpSW9Ib3N0LFxuICBjb25jdXJyZW5jeTogbnVtYmVyLFxuICBtb3RpdmF0aW9uOiBzdHJpbmcsXG4gIHF1ZXN0aW9uOiBzdHJpbmcsXG4pIHtcbiAgYXdhaXQgaW9Ib3N0LndpdGhDb3JrZWRMb2dnaW5nKGFzeW5jICgpID0+IHtcbiAgICAvLyBvbmx5IHRhbGsgdG8gdXNlciBpZiBTVERJTiBpcyBhIHRlcm1pbmFsIChvdGhlcndpc2UsIGZhaWwpXG4gICAgaWYgKCFURVNUSU5HICYmICFwcm9jZXNzLnN0ZGluLmlzVFRZKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGAke21vdGl2YXRpb259LCBidXQgdGVybWluYWwgKFRUWSkgaXMgbm90IGF0dGFjaGVkIHNvIHdlIGFyZSB1bmFibGUgdG8gZ2V0IGEgY29uZmlybWF0aW9uIGZyb20gdGhlIHVzZXJgKTtcbiAgICB9XG5cbiAgICAvLyBvbmx5IHRhbGsgdG8gdXNlciBpZiBjb25jdXJyZW5jeSBpcyAxIChvdGhlcndpc2UsIGZhaWwpXG4gICAgaWYgKGNvbmN1cnJlbmN5ID4gMSkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgJHttb3RpdmF0aW9ufSwgYnV0IGNvbmN1cnJlbmN5IGlzIGdyZWF0ZXIgdGhhbiAxIHNvIHdlIGFyZSB1bmFibGUgdG8gZ2V0IGEgY29uZmlybWF0aW9uIGZyb20gdGhlIHVzZXJgKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25maXJtZWQgPSBhd2FpdCBwcm9tcHRseS5jb25maXJtKGAke2NoYWxrLmN5YW4ocXVlc3Rpb24pfSAoeS9uKT9gKTtcbiAgICBpZiAoIWNvbmZpcm1lZCkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignQWJvcnRlZCBieSB1c2VyJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBMb2dnZXIgZm9yIHByb2Nlc3Npbmcgc3RhY2sgbWV0YWRhdGFcbiAqL1xuZnVuY3Rpb24gc3RhY2tNZXRhZGF0YUxvZ2dlcih2ZXJib3NlPzogYm9vbGVhbik6IChsZXZlbDogJ2luZm8nIHwgJ2Vycm9yJyB8ICd3YXJuJywgbXNnOiBjeGFwaS5TeW50aGVzaXNNZXNzYWdlKSA9PiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgbWFrZUxvZ2dlciA9IChsZXZlbDogc3RyaW5nKTogW2xvZ2dlcjogKG06IHN0cmluZykgPT4gdm9pZCwgcHJlZml4OiBzdHJpbmddID0+IHtcbiAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHJldHVybiBbZXJyb3IsICdFcnJvciddO1xuICAgICAgY2FzZSAnd2Fybic6XG4gICAgICAgIHJldHVybiBbd2FybmluZywgJ1dhcm5pbmcnXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbaW5mbywgJ0luZm8nXTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGFzeW5jIChsZXZlbCwgbXNnKSA9PiB7XG4gICAgY29uc3QgW2xvZ0ZuLCBwcmVmaXhdID0gbWFrZUxvZ2dlcihsZXZlbCk7XG4gICAgbG9nRm4oYFske3ByZWZpeH0gYXQgJHttc2cuaWR9XSAke21zZy5lbnRyeS5kYXRhfWApO1xuXG4gICAgaWYgKHZlcmJvc2UgJiYgbXNnLmVudHJ5LnRyYWNlKSB7XG4gICAgICBsb2dGbihgICAke21zZy5lbnRyeS50cmFjZS5qb2luKCdcXG4gICcpfWApO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgbWFudWFsIGFwcHJvdmFsIGlzIHJlcXVpcmVkIG9yIG5vdC4gUmVxdWlyZXMgYXBwcm92YWwgZm9yXG4gKiAtIFJlcXVpcmVBcHByb3ZhbC5BTllfQ0hBTkdFXG4gKiAtIFJlcXVpcmVBcHByb3ZhbC5CUk9BREVOSU5HIGFuZCB0aGUgY2hhbmdlcyBhcmUgaW5kZWVkIGJyb2FkZW5pbmcgcGVybWlzc2lvbnNcbiAqL1xuZnVuY3Rpb24gcmVxdWlyZXNBcHByb3ZhbChyZXF1aXJlQXBwcm92YWw6IFJlcXVpcmVBcHByb3ZhbCwgcGVybWlzc2lvbkNoYW5nZVR5cGU6IFBlcm1pc3Npb25DaGFuZ2VUeXBlKSB7XG4gIHJldHVybiByZXF1aXJlQXBwcm92YWwgPT09IFJlcXVpcmVBcHByb3ZhbC5BTllfQ0hBTkdFIHx8XG4gIHJlcXVpcmVBcHByb3ZhbCA9PT0gUmVxdWlyZUFwcHJvdmFsLkJST0FERU5JTkcgJiYgcGVybWlzc2lvbkNoYW5nZVR5cGUgPT09IFBlcm1pc3Npb25DaGFuZ2VUeXBlLkJST0FERU5JTkc7XG59XG4iXX0=